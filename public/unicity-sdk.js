/*! For license information please see unicity-sdk.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.UnicitySDK=e():t.UnicitySDK=e()}(self,()=>(()=>{"use strict";var t,e,r={d:(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},n={};r.r(n),r.d(n,{AddressScheme:()=>t,AggregatorClient:()=>Rr,Authenticator:()=>or,BurnPredicate:()=>Tr,CoinId:()=>Yr,Commitment:()=>kr,DataHash:()=>Rt,DataHasher:()=>It,DefaultPredicate:()=>Ir,DirectAddress:()=>vt,HashAlgorithm:()=>Et,HexConverter:()=>S,InclusionProof:()=>gr,InclusionProofVerificationStatus:()=>fr,MINTER_SECRET:()=>Fr,MINT_SUFFIX:()=>Lr,MaskedPredicate:()=>_r,MintTransactionData:()=>Kr,NameTagAddress:()=>_t,NameTagTokenData:()=>Pr,PredicateFactory:()=>Hr,PredicateType:()=>Or,RequestId:()=>Ut,Signature:()=>Ct,SigningService:()=>nr,StateTransitionClient:()=>$r,SubmitCommitmentResponse:()=>Nr,SubmitCommitmentStatus:()=>Br,TOKEN_VERSION:()=>Dr,Token:()=>Jr,TokenCoinData:()=>zr,TokenFactory:()=>Zr,TokenId:()=>qr,TokenState:()=>Gr,TokenType:()=>jr,Transaction:()=>Mr,TransactionData:()=>Vr,UnmaskedPredicate:()=>Cr}),function(t){t.DIRECT="DIRECT",t.PROXY="PROXY"}(t||(t={}));class i extends Error{}!function(t){t[t.UNSIGNED_INTEGER=0]="UNSIGNED_INTEGER",t[t.NEGATIVE_INTEGER=32]="NEGATIVE_INTEGER",t[t.BYTE_STRING=64]="BYTE_STRING",t[t.TEXT_STRING=96]="TEXT_STRING",t[t.ARRAY=128]="ARRAY",t[t.MAP=160]="MAP",t[t.TAG=192]="TAG",t[t.FLOAT_SIMPLE_BREAK=224]="FLOAT_SIMPLE_BREAK"}(e||(e={}));const o="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function s(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function a(t,...e){if(!((r=t)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function c(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function h(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function u(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function l(t,e){return t<<32-e|t>>>e}function d(t,e){return t<<e|t>>>32-e>>>0}const f=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),g=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function y(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function p(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),a(t),t}class w{}function m(t){const e=e=>t().update(p(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function b(t=32){if(o&&"function"==typeof o.getRandomValues)return o.getRandomValues(new Uint8Array(t));if(o&&"function"==typeof o.randomBytes)return Uint8Array.from(o.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}class S{static encode(t){return function(t){if(a(t),f)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=g[t[r]];return e}(t)}static decode(t){return function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(f)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=y(t.charCodeAt(i)),o=y(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}(t)}}class A{static encodeOptional(t,e){return null==t?new Uint8Array([246]):e(t)}static encodeUnsignedInteger(t){if(t<0)throw new i("Only unsigned numbers are allowed.");if(t<24)return new Uint8Array([e.UNSIGNED_INTEGER|Number(t)]);const r=A.getUnsignedIntegerAsPaddedBytes(t);return new Uint8Array([e.UNSIGNED_INTEGER|A.getAdditionalInformationBits(r.length),...r])}static encodeByteString(t){if(t.length<24)return new Uint8Array([e.BYTE_STRING|t.length,...t]);const r=A.getUnsignedIntegerAsPaddedBytes(t.length);return new Uint8Array([e.BYTE_STRING|A.getAdditionalInformationBits(r.length),...r,...t])}static encodeTextString(t){const r=(new TextEncoder).encode(t);if(r.length<24)return new Uint8Array([e.TEXT_STRING|r.length,...r]);const n=A.getUnsignedIntegerAsPaddedBytes(r.length);return new Uint8Array([e.TEXT_STRING|A.getAdditionalInformationBits(n.length),...n,...r])}static encodeArray(t){const r=new Uint8Array(t.reduce((t,e)=>t+e.length,0));let n=0;for(const e of t)r.set(e,n),n+=e.length;if(t.length<24)return new Uint8Array([e.ARRAY|t.length,...r]);const i=A.getUnsignedIntegerAsPaddedBytes(t.length);return new Uint8Array([e.ARRAY|A.getAdditionalInformationBits(i.length),...i,...r])}static encodeMap(t){const r=Array.from(t.entries()).map(([t,e])=>[S.decode(t),e]);r.sort(([t],[e])=>{if(t.length!==e.length)return t.length-e.length;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]-e[r];return 0});const n=r.reduce((t,[e,r])=>t+e.length+r.length,0),i=new Uint8Array(n);let o=0;for(const[t,e]of r)i.set(t,o),o+=t.length,i.set(e,o),o+=e.length;if(t.size<24)return new Uint8Array([e.MAP|t.size,...i]);const s=A.getUnsignedIntegerAsPaddedBytes(t.size);return new Uint8Array([e.MAP|A.getAdditionalInformationBits(s.length),...s,...i])}static encodeTag(t,r){if(t<24)return new Uint8Array([e.TAG|Number(t),...r]);const n=A.getUnsignedIntegerAsPaddedBytes(t);return new Uint8Array([e.TAG|A.getAdditionalInformationBits(n.length),...n,...r])}static encodeBoolean(t){return t?new Uint8Array([245]):new Uint8Array([244])}static encodeNull(){return new Uint8Array([246])}static getAdditionalInformationBits(t){return 24+Math.ceil(Math.log2(t))}static getUnsignedIntegerAsPaddedBytes(t){if(t<0)throw new i("Only unsigned numbers are allowed.");let e;const r=[];for(e=BigInt(t);e>0;e>>=8n)r.push(Number(255n&e));if(r.length>8)throw new i("Number is not unsigned long.");0===r.length&&r.push(0),r.reverse();const n=new Uint8Array(Math.pow(2,Math.ceil(Math.log2(r.length))));return n.set(r,n.length-r.length),n}}function E(t,e,r){return t&e^~t&r}function B(t,e,r){return t&e^t&r^e&r}class O extends w{constructor(t,e,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(t),this.view=u(this.buffer)}update(t){c(this),a(t=p(t));const{view:e,buffer:r,blockLen:n}=this,i=t.length;for(let o=0;o<i;){const s=Math.min(n-this.pos,i-o);if(s===n){const e=u(t);for(;n<=i-o;o+=n)this.process(e,o);continue}r.set(t.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===n&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){c(this),function(t,e){a(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:i}=this;let{pos:o}=this;e[o++]=128,h(this.buffer.subarray(o)),this.padOffset>n-o&&(this.process(r,0),o=0);for(let t=o;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),c=n?4:0,h=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+h,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const s=u(t),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=l/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<d;t++)s.setUint32(4*t,f[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.destroyed=o,t.finished=i,t.length=n,t.pos=s,n%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const N=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),R=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),x=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),T=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),I=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),v=(()=>Uint8Array.from(new Array(16).fill(0).map((t,e)=>e)))(),_=(()=>v.map(t=>(9*t+5)%16))(),U=(()=>{const t=[[v],[_]];for(let e=0;e<4;e++)for(let r of t)r.push(r[e].map(t=>I[t]));return t})(),C=(()=>U[0])(),H=(()=>U[1])(),P=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>Uint8Array.from(t)),D=C.map((t,e)=>t.map(t=>P[e][t])),J=H.map((t,e)=>t.map(t=>P[e][t])),k=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),K=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function M(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const L=new Uint32Array(16);class F extends O{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:i}=this;return[t,e,r,n,i]}set(t,e,r,n,i){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(t,e){for(let r=0;r<16;r++,e+=4)L[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,i=0|this.h1,o=i,s=0|this.h2,a=s,c=0|this.h3,h=c,u=0|this.h4,l=u;for(let t=0;t<5;t++){const e=4-t,f=k[t],g=K[t],y=C[t],p=H[t],w=D[t],m=J[t];for(let e=0;e<16;e++){const n=d(r+M(t,i,s,c)+L[y[e]]+f,w[e])+u|0;r=u,u=c,c=0|d(s,10),s=i,i=n}for(let t=0;t<16;t++){const r=d(n+M(e,o,a,h)+L[p[t]]+g,m[t])+l|0;n=l,l=h,h=0|d(a,10),a=o,o=r}}this.set(this.h1+s+h|0,this.h2+c+l|0,this.h3+u+n|0,this.h4+r+o|0,this.h0+i+a|0)}roundClean(){h(L)}destroy(){this.destroyed=!0,h(this.buffer),this.set(0,0,0,0,0)}}const $=m(()=>new F),q=BigInt(2**32-1),G=BigInt(32);function j(t,e=!1){return e?{h:Number(t&q),l:Number(t>>G&q)}:{h:0|Number(t>>G&q),l:0|Number(t&q)}}const V=(t,e,r)=>t>>>r,Y=(t,e,r)=>t<<32-r|e>>>r,z=(t,e,r)=>t>>>r|e<<32-r,Z=(t,e,r)=>t<<32-r|e>>>r,W=(t,e,r)=>t<<64-r|e>>>r-32,X=(t,e,r)=>t>>>r-32|e<<64-r;function Q(t,e,r,n){const i=(e>>>0)+(n>>>0);return{h:t+r+(i/2**32|0)|0,l:0|i}}const tt=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),et=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,rt=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),nt=(t,e,r,n,i)=>e+r+n+i+(t/2**32|0)|0,it=(t,e,r,n,i)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0),ot=(t,e,r,n,i,o)=>e+r+n+i+o+(t/2**32|0)|0,st=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),at=new Uint32Array(64);class ct extends O{constructor(t=32){super(64,t,8,!1),this.A=0|N[0],this.B=0|N[1],this.C=0|N[2],this.D=0|N[3],this.E=0|N[4],this.F=0|N[5],this.G=0|N[6],this.H=0|N[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[t,e,r,n,i,o,s,a]}set(t,e,r,n,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)at[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=at[t-15],r=at[t-2],n=l(e,7)^l(e,18)^e>>>3,i=l(r,17)^l(r,19)^r>>>10;at[t]=i+at[t-7]+n+at[t-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:a,G:c,H:h}=this;for(let t=0;t<64;t++){const e=h+(l(s,6)^l(s,11)^l(s,25))+E(s,a,c)+st[t]+at[t]|0,u=(l(r,2)^l(r,13)^l(r,22))+B(r,n,i)|0;h=c,c=a,a=s,s=o+e|0,o=i,i=n,n=r,r=e+u|0}r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,h=h+this.H|0,this.set(r,n,i,o,s,a,c,h)}roundClean(){h(at)}destroy(){this.set(0,0,0,0,0,0,0,0),h(this.buffer)}}class ht extends ct{constructor(){super(28),this.A=0|R[0],this.B=0|R[1],this.C=0|R[2],this.D=0|R[3],this.E=0|R[4],this.F=0|R[5],this.G=0|R[6],this.H=0|R[7]}}const ut=(()=>function(t,e=!1){const r=t.length;let n=new Uint32Array(r),i=new Uint32Array(r);for(let o=0;o<r;o++){const{h:r,l:s}=j(t[o],e);[n[o],i[o]]=[r,s]}return[n,i]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),lt=(()=>ut[0])(),dt=(()=>ut[1])(),ft=new Uint32Array(80),gt=new Uint32Array(80);class yt extends O{constructor(t=64){super(128,t,16,!1),this.Ah=0|T[0],this.Al=0|T[1],this.Bh=0|T[2],this.Bl=0|T[3],this.Ch=0|T[4],this.Cl=0|T[5],this.Dh=0|T[6],this.Dl=0|T[7],this.Eh=0|T[8],this.El=0|T[9],this.Fh=0|T[10],this.Fl=0|T[11],this.Gh=0|T[12],this.Gl=0|T[13],this.Hh=0|T[14],this.Hl=0|T[15]}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:a,Eh:c,El:h,Fh:u,Fl:l,Gh:d,Gl:f,Hh:g,Hl:y}=this;return[t,e,r,n,i,o,s,a,c,h,u,l,d,f,g,y]}set(t,e,r,n,i,o,s,a,c,h,u,l,d,f,g,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|h,this.Fh=0|u,this.Fl=0|l,this.Gh=0|d,this.Gl=0|f,this.Hh=0|g,this.Hl=0|y}process(t,e){for(let r=0;r<16;r++,e+=4)ft[r]=t.getUint32(e),gt[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|ft[t-15],r=0|gt[t-15],n=z(e,r,1)^z(e,r,8)^V(e,0,7),i=Z(e,r,1)^Z(e,r,8)^Y(e,r,7),o=0|ft[t-2],s=0|gt[t-2],a=z(o,s,19)^W(o,s,61)^V(o,0,6),c=Z(o,s,19)^X(o,s,61)^Y(o,s,6),h=rt(i,c,gt[t-7],gt[t-16]),u=nt(h,n,a,ft[t-7],ft[t-16]);ft[t]=0|u,gt[t]=0|h}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:a,Dh:c,Dl:h,Eh:u,El:l,Fh:d,Fl:f,Gh:g,Gl:y,Hh:p,Hl:w}=this;for(let t=0;t<80;t++){const e=z(u,l,14)^z(u,l,18)^W(u,l,41),m=Z(u,l,14)^Z(u,l,18)^X(u,l,41),b=u&d^~u&g,S=it(w,m,l&f^~l&y,dt[t],gt[t]),A=ot(S,p,e,b,lt[t],ft[t]),E=0|S,B=z(r,n,28)^W(r,n,34)^W(r,n,39),O=Z(r,n,28)^X(r,n,34)^X(r,n,39),N=r&i^r&s^i&s,R=n&o^n&a^o&a;p=0|g,w=0|y,g=0|d,y=0|f,d=0|u,f=0|l,({h:u,l}=Q(0|c,0|h,0|A,0|E)),c=0|s,h=0|a,s=0|i,a=0|o,i=0|r,o=0|n;const x=tt(E,O,R);r=et(x,A,B,N),n=0|x}({h:r,l:n}=Q(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=Q(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:a}=Q(0|this.Ch,0|this.Cl,0|s,0|a)),({h:c,l:h}=Q(0|this.Dh,0|this.Dl,0|c,0|h)),({h:u,l}=Q(0|this.Eh,0|this.El,0|u,0|l)),({h:d,l:f}=Q(0|this.Fh,0|this.Fl,0|d,0|f)),({h:g,l:y}=Q(0|this.Gh,0|this.Gl,0|g,0|y)),({h:p,l:w}=Q(0|this.Hh,0|this.Hl,0|p,0|w)),this.set(r,n,i,o,s,a,c,h,u,l,d,f,g,y,p,w)}roundClean(){h(ft,gt)}destroy(){h(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class pt extends yt{constructor(){super(48),this.Ah=0|x[0],this.Al=0|x[1],this.Bh=0|x[2],this.Bl=0|x[3],this.Ch=0|x[4],this.Cl=0|x[5],this.Dh=0|x[6],this.Dl=0|x[7],this.Eh=0|x[8],this.El=0|x[9],this.Fh=0|x[10],this.Fl=0|x[11],this.Gh=0|x[12],this.Gl=0|x[13],this.Hh=0|x[14],this.Hl=0|x[15]}}const wt=m(()=>new ct),mt=wt,bt=m(()=>new ht),St=m(()=>new yt),At=m(()=>new pt);var Et,Bt;!function(t){t[t.SHA256=0]="SHA256",t[t.SHA224=1]="SHA224",t[t.SHA384=2]="SHA384",t[t.SHA512=3]="SHA512",t[t.RIPEMD160=4]="RIPEMD160"}(Et||(Et={}));class Ot extends Error{constructor(t){super(t),this.name="HashError"}}!function(t){t[t.MAJOR_TYPE=224]="MAJOR_TYPE",t[t.ADDITIONAL_INFORMATION=31]="ADDITIONAL_INFORMATION"}(Bt||(Bt={}));class Nt{static readOptional(t,e){return 246===Nt.readByte(t,0)?null:e(t)}static readUnsignedInteger(t){const r=Nt.readByte(t,0)&Bt.MAJOR_TYPE;if(r!=e.UNSIGNED_INTEGER)throw new i("Major type mismatch, expected unsigned integer.");return Nt.readLength(r,t,0).length}static readNegativeInteger(){throw new i("Not implemented.")}static readByteString(t){const r=Nt.readByte(t,0)&Bt.MAJOR_TYPE;if(r!=e.BYTE_STRING)throw new i("Major type mismatch, expected byte string.");const{length:n,position:o}=Nt.readLength(r,t,0);return Nt.read(t,o,Number(n))}static readTextString(t){const r=Nt.readByte(t,0)&Bt.MAJOR_TYPE;if(r!=e.TEXT_STRING)throw new i("Major type mismatch, expected text string.");const{length:n,position:o}=Nt.readLength(r,t,0);return(new TextDecoder).decode(Nt.read(t,o,Number(n)))}static readArray(t){const r=Nt.readByte(t,0)&Bt.MAJOR_TYPE;if(r!=e.ARRAY)throw new i("Major type mismatch, expected array.");const n=Nt.readLength(r,t,0);let o=n.position;const s=[];for(let e=0;e<n.length;e++){const e=Nt.readRawCbor(t,o);o=e.position,s.push(e.data)}return s}static readMap(t){const r=Nt.readByte(t,0)&Bt.MAJOR_TYPE;if(r!=e.MAP)throw new i("Major type mismatch, expected map.");const n=Nt.readLength(r,t,0);let o=n.position;const s=new Map;for(let e=0;e<n.length;e++){const e=Nt.readRawCbor(t,o);o=e.position;const r=Nt.readRawCbor(t,o);o=r.position,s.set(S.encode(e.data),r.data)}return s}static readTag(t){const r=Nt.readByte(t,0)&Bt.MAJOR_TYPE;if(r!=e.TAG)throw new i("Major type mismatch, expected tag.");const{length:n,position:o}=Nt.readLength(r,t,0);return{data:Nt.readRawCbor(t,o).data,tag:n}}static readBoolean(t){const e=Nt.readByte(t,0);if(245===e)return!0;if(244===e)return!1;throw new i("Type mismatch, expected boolean.")}static readLength(t,r,n){const o=Nt.readByte(r,n)&Bt.ADDITIONAL_INFORMATION;if(o<24)return{length:BigInt(o),position:n+1};switch(t){case e.ARRAY:case e.BYTE_STRING:case e.TEXT_STRING:if(31==o)throw new i("Indefinite length array not supported.")}if(o>27)throw new i("Encoded item is not well-formed.");const s=Math.pow(2,o-24);let a=BigInt(0);for(let t=0;t<s;++t)a=a<<8n|BigInt(Nt.readByte(r,n+1+t));return{length:a,position:n+s+1}}static readRawCbor(t,r){const n=Nt.readByte(t,r)&Bt.MAJOR_TYPE,i=Nt.readLength(n,t,r),o=i.length;let s=i.position;switch(n){case e.BYTE_STRING:case e.TEXT_STRING:s+=Number(o);break;case e.ARRAY:for(let e=0;e<o;e++)s=Nt.readRawCbor(t,s).position;break;case e.MAP:for(let e=0;e<o;e++)s=Nt.readRawCbor(t,s).position,s=Nt.readRawCbor(t,s).position;break;case e.TAG:s=Nt.readRawCbor(t,s).position}return{data:Nt.read(t,r,s-r),position:s}}static readByte(t,e){if(t.length<e)throw new i("Premature end of data.");return 255&t[e]}static read(t,e,r){if(t.length<e+r)throw new i("Premature end of data.");return t.subarray(e,e+r)}}class Rt{algorithm;_data;_imprint;constructor(t,e){this.algorithm=t,this._data=e,this._data=new Uint8Array(e),this._imprint=new Uint8Array(e.length+2),this._imprint.set([(65280&t)>>8,255&t]),this._imprint.set(new Uint8Array(e),2)}get data(){return new Uint8Array(this._data)}get imprint(){return new Uint8Array(this._imprint)}static fromImprint(t){if(t.length<3)throw new Ot("Imprint must have 2 bytes of algorithm and at least 1 byte of data.");const e=t[0]<<8|t[1];return new Rt(e,t.subarray(2))}static fromJSON(t){return Rt.fromImprint(S.decode(t))}static fromCBOR(t){return Rt.fromImprint(Nt.readByteString(t))}toJSON(){return S.encode(this._imprint)}toCBOR(){return A.encodeByteString(this._imprint)}equals(t){return S.encode(this._imprint)===S.encode(t._imprint)}toString(){return`[${Et[this.algorithm]}]${S.encode(this._data)}`}}class xt extends Error{constructor(t){super(`Unsupported hash algorithm: ${t}`),this.name="UnsupportedHashAlgorithm"}}const Tt={[Et.RIPEMD160]:$,[Et.SHA224]:bt,[Et.SHA256]:mt,[Et.SHA384]:At,[Et.SHA512]:St};class It{algorithm;_messageDigest;constructor(t){if(this.algorithm=t,!Tt[t])throw new xt(t);this._messageDigest=Tt[t].create()}update(t){return this._messageDigest.update(t),this}digest(){return Promise.resolve(new Rt(this.algorithm,this._messageDigest.digest()))}}class vt{data;checksum;constructor(t,e){this.data=t,this.checksum=e,this.checksum=new Uint8Array(e.slice(0,4))}get scheme(){return t.DIRECT}static async create(t){const e=await new It(Et.SHA256).update(t.toCBOR()).digest();return new vt(t,e.data.slice(0,4))}toJSON(){return this.toString()}toCBOR(){return A.encodeTextString(this.toString())}toString(){return`${this.scheme}://${S.encode(this.data.toCBOR())}${S.encode(this.checksum)}`}}class _t{_data;constructor(t){this._data=t,this._data=new Uint8Array(t)}get data(){return new Uint8Array(this._data)}get scheme(){return t.PROXY}toJSON(){return`${this.scheme}://${S.encode(this._data)}`}toString(){return`NameTagAddress[${S.encode(this._data)}]`}}class Ut{hash;constructor(t){this.hash=t}static create(t,e){return Ut.createFromImprint(t,e.imprint)}static async createFromImprint(t,e){const r=await new It(Et.SHA256).update(t).update(e).digest();return new Ut(r)}static fromCBOR(t){return new Ut(Rt.fromCBOR(t))}static fromJSON(t){return new Ut(Rt.fromJSON(t))}toBigInt(){return BigInt(`0x01${S.encode(this.hash.imprint)}`)}toJSON(){return this.hash.toJSON()}toCBOR(){return this.hash.toCBOR()}equals(t){return this.hash.equals(t.hash)}toString(){return`RequestId[${this.hash.toString()}]`}}class Ct{_bytes;recovery;algorithm="secp256k1";constructor(t,e){this._bytes=t,this.recovery=e,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static fromCBOR(t){return Ct.decode(Nt.readByteString(t))}static decode(t){if(65!==t.length)throw new Error("Signature must contain signature and recovery byte.");return new Ct(t.slice(0,-1),t[t.length-1])}static fromJSON(t){return Ct.decode(S.decode(t))}toJSON(){return S.encode(this.encode())}toCBOR(){return A.encodeByteString(this.encode())}encode(){return new Uint8Array([...this._bytes,this.recovery])}toString(){return`${S.encode(this.encode())}`}}class Ht extends w{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");s(t.outputLen),s(t.blockLen)}(t);const r=p(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),h(i)}update(t){return c(this),this.iHash.update(t),this}digestInto(t){c(this),a(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Pt=(t,e,r)=>new Ht(t,e).update(r).digest();Pt.create=(t,e)=>new Ht(t,e);const Dt=BigInt(0),Jt=BigInt(1);function kt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function Kt(t){if(!kt(t))throw new Error("Uint8Array expected")}function Mt(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}function Lt(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function Ft(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Dt:BigInt("0x"+t)}const $t="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,qt=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Gt(t){if(Kt(t),$t)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=qt[t[r]];return e}function jt(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function Vt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if($t)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=jt(t.charCodeAt(i)),o=jt(t.charCodeAt(i+1));if(void 0===r||void 0===o){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+o}return n}function Yt(t){return Ft(Gt(t))}function zt(t){return Kt(t),Ft(Gt(Uint8Array.from(t).reverse()))}function Zt(t,e){return Vt(t.toString(16).padStart(2*e,"0"))}function Wt(t,e){return Zt(t,e).reverse()}function Xt(t,e,r){let n;if("string"==typeof e)try{n=Vt(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!kt(e))throw new Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(t+" of length "+r+" expected, got "+i);return n}function Qt(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];Kt(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const te=t=>"bigint"==typeof t&&Dt<=t;function ee(t,e,r){return te(t)&&te(e)&&te(r)&&e<=t&&t<r}function re(t,e,r,n){if(!ee(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}const ne=t=>(Jt<<BigInt(t))-Jt,ie=t=>new Uint8Array(t),oe=t=>Uint8Array.from(t),se={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||kt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function ae(t,e,r={}){const n=(e,r,n)=>{const i=se[r];if("function"!=typeof i)throw new Error("invalid validator function");const o=t[e];if(!(n&&void 0===o||i(o,t)))throw new Error("param "+String(e)+" is invalid. Expected "+r+", got "+o)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}function ce(t){const e=new WeakMap;return(r,...n)=>{const i=e.get(r);if(void 0!==i)return i;const o=t(r,...n);return e.set(r,o),o}}const he=BigInt(0),ue=BigInt(1),le=BigInt(2),de=BigInt(3),fe=BigInt(4),ge=BigInt(5),ye=BigInt(8);function pe(t,e){const r=t%e;return r>=he?r:e+r}function we(t,e,r){let n=t;for(;e-- >he;)n*=n,n%=r;return n}function me(t,e){if(t===he)throw new Error("invert: expected non-zero number");if(e<=he)throw new Error("invert: expected positive modulus, got "+e);let r=pe(t,e),n=e,i=he,o=ue,s=ue,a=he;for(;r!==he;){const t=n/r,e=n%r,c=i-s*t,h=o-a*t;n=r,r=e,i=s,o=a,s=c,a=h}if(n!==ue)throw new Error("invert: does not exist");return pe(i,e)}function be(t,e){const r=(t.ORDER+ue)/fe,n=t.pow(e,r);if(!t.eql(t.sqr(n),e))throw new Error("Cannot find square root");return n}function Se(t,e){const r=(t.ORDER-ge)/ye,n=t.mul(e,le),i=t.pow(n,r),o=t.mul(e,i),s=t.mul(t.mul(o,le),i),a=t.mul(o,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),e))throw new Error("Cannot find square root");return a}const Ae=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ee(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),i=e.reduce((e,r,i)=>t.is0(r)?e:(n[i]=e,t.mul(e,r)),t.ONE),o=t.inv(i);return e.reduceRight((e,r,i)=>t.is0(r)?e:(n[i]=t.mul(e,n[i]),t.mul(e,r)),o),n}function Be(t,e){const r=(t.ORDER-ue)/le,n=t.pow(e,r),i=t.eql(n,t.ONE),o=t.eql(n,t.ZERO),s=t.eql(n,t.neg(t.ONE));if(!i&&!o&&!s)throw new Error("invalid Legendre symbol result");return i?1:o?0:-1}function Oe(t,e){void 0!==e&&s(e);const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Ne(t,e,r=!1,n={}){if(t<=he)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:o}=Oe(t,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const a=Object.freeze({ORDER:t,isLE:r,BITS:i,BYTES:o,MASK:ne(i),ZERO:he,ONE:ue,create:e=>pe(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return he<=e&&e<t},is0:t=>t===he,isOdd:t=>(t&ue)===ue,neg:e=>pe(-e,t),eql:(t,e)=>t===e,sqr:e=>pe(e*e,t),add:(e,r)=>pe(e+r,t),sub:(e,r)=>pe(e-r,t),mul:(e,r)=>pe(e*r,t),pow:(t,e)=>function(t,e,r){if(r<he)throw new Error("invalid exponent, negatives unsupported");if(r===he)return t.ONE;if(r===ue)return e;let n=t.ONE,i=e;for(;r>he;)r&ue&&(n=t.mul(n,i)),i=t.sqr(i),r>>=ue;return n}(a,t,e),div:(e,r)=>pe(e*me(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>me(e,t),sqrt:n.sqrt||(e=>{return s||(s=(r=t)%fe===de?be:r%ye===ge?Se:function(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-ue,r=0;for(;e%le===he;)e/=le,r++;let n=le;const i=Ne(t);for(;1===Be(i,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return be;let o=i.pow(n,e);const s=(e+ue)/le;return function(t,n){if(t.is0(n))return n;if(1!==Be(t,n))throw new Error("Cannot find square root");let i=r,a=t.mul(t.ONE,o),c=t.pow(n,e),h=t.pow(n,s);for(;!t.eql(c,t.ONE);){if(t.is0(c))return t.ZERO;let e=1,r=t.sqr(c);for(;!t.eql(r,t.ONE);)if(e++,r=t.sqr(r),e===i)throw new Error("Cannot find square root");const n=ue<<BigInt(i-e-1),o=t.pow(a,n);i=e,a=t.sqr(o),c=t.mul(c,a),h=t.mul(h,o)}return h}}(r)),s(a,e);var r}),toBytes:t=>r?Wt(t,o):Zt(t,o),fromBytes:t=>{if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);return r?zt(t):Yt(t)},invertBatch:t=>Ee(a,t),cmov:(t,e,r)=>r?e:t});return Object.freeze(a)}function Re(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function xe(t){const e=Re(t);return e+Math.ceil(e/2)}const Te=BigInt(0),Ie=BigInt(1);function ve(t,e){const r=e.negate();return t?r:e}function _e(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Ue(t,e){_e(t,e);const r=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:ne(t),maxNumber:r,shiftBy:BigInt(t)}}function Ce(t,e,r){const{windowSize:n,mask:i,maxNumber:o,shiftBy:s}=r;let a=Number(t&i),c=t>>s;a>n&&(a-=o,c+=Ie);const h=e*n;return{nextN:c,offset:h+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:h}}const He=new WeakMap,Pe=new WeakMap;function De(t){return Pe.get(t)||1}function Je(t,e,r,n){(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})})(r,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}(n,e);const i=r.length,o=n.length;if(i!==o)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,a=function(t){let e;for(e=0;t>Dt;t>>=Jt,e+=1);return e}(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const h=ne(c),u=new Array(Number(h)+1).fill(s);let l=s;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){u.fill(s);for(let e=0;e<o;e++){const i=n[e],o=Number(i>>BigInt(t)&h);u[o]=u[o].add(r[e])}let e=s;for(let t=u.length-1,r=s;t>0;t--)r=r.add(u[t]),e=e.add(r);if(l=l.add(e),0!==t)for(let t=0;t<c;t++)l=l.double()}return l}function ke(t){return ae(t.Fp,Ae.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),ae(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Oe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Ke(t){void 0!==t.lowS&&Mt("lowS",t.lowS),void 0!==t.prehash&&Mt("prehash",t.prehash)}class Me extends Error{constructor(t=""){super(t)}}const Le={Err:Me,_tlv:{encode:(t,e)=>{const{Err:r}=Le;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,i=Lt(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?Lt(i.length/2|128):"";return Lt(t)+o+i+e},decode(t,e){const{Err:r}=Le;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const i=e[n++];let o=0;if(128&i){const t=127&i;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const s=e.subarray(n,n+t);if(s.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===s[0])throw new r("tlv.decode(long): zero leftmost byte");for(const t of s)o=o<<8|t;if(n+=t,o<128)throw new r("tlv.decode(long): not minimal encoding")}else o=i;const s=e.subarray(n,n+o);if(s.length!==o)throw new r("tlv.decode: wrong value length");return{v:s,l:e.subarray(n+o)}}},_int:{encode(t){const{Err:e}=Le;if(t<$e)throw new e("integer: negative integers are not allowed");let r=Lt(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=Le;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return Yt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=Le,i=Xt("signature",t),{v:o,l:s}=n.decode(48,i);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,o),{v:h,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(h)}},hexFromSig(t){const{_tlv:e,_int:r}=Le,n=e.encode(2,r.encode(t.r))+e.encode(2,r.encode(t.s));return e.encode(48,n)}};function Fe(t,e){return Gt(Zt(t,e))}const $e=BigInt(0),qe=BigInt(1),Ge=(BigInt(2),BigInt(3)),je=BigInt(4);function Ve(t){const e=function(t){const e=ke(t);return ae(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n,nByteLength:i,nBitLength:o}=e,s=r.BYTES+1,a=2*r.BYTES+1;function c(t){return pe(t,n)}function h(t){return me(t,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:f}=function(t){const e=function(t){const e=ke(t);ae(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}(t),{Fp:r}=e,n=Ne(e.n,e.nBitLength),i=e.toBytes||((t,e,n)=>{const i=e.toAffine();return Qt(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),o=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function s(t){const{a:n,b:i}=e,o=r.sqr(t),s=r.mul(o,t);return r.add(r.add(s,r.mul(t,n)),i)}function a(t,e){const n=r.sqr(e),i=s(t);return r.eql(n,i)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=r.mul(r.pow(e.a,Ge),je),h=r.mul(r.sqr(e.b),BigInt(27));if(r.is0(r.add(c,h)))throw new Error("bad curve params: a or b");function u(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=e;if(r&&"bigint"!=typeof t){if(kt(t)&&(t=Gt(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:Yt(Xt("private key",t,n))}catch(e){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return i&&(s=pe(s,o)),re("private key",s,qe,o),s}function l(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const d=ce((t,e)=>{const{px:n,py:i,pz:o}=t;if(r.eql(o,r.ONE))return{x:n,y:i};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(o));const a=r.mul(n,e),c=r.mul(i,e),h=r.mul(o,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(h,r.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),f=ce(t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:n,y:i}=t.toAffine();if(!r.isValid(n)||!r.isValid(i))throw new Error("bad point: x or y not FE");if(!a(n,i))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(t,e,n){if(null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e)||r.is0(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required");this.px=t,this.py=e,this.pz=n,Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const i=t=>r.eql(t,r.ZERO);return i(e)&&i(n)?g.ZERO:new g(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=Ee(r,t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(o(Xt("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(u(t))}static msm(t,e){return Je(g,n,t,e)}_setWindowSize(t){w.setWindowSize(this,t)}assertValidity(){f(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){l(t);const{px:e,py:n,pz:i}=this,{px:o,py:s,pz:a}=t,c=r.eql(r.mul(e,a),r.mul(o,i)),h=r.eql(r.mul(n,a),r.mul(s,i));return c&&h}negate(){return new g(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,Ge),{px:o,py:s,pz:a}=this;let c=r.ZERO,h=r.ZERO,u=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),f=r.mul(a,a),y=r.mul(o,s);return y=r.add(y,y),u=r.mul(o,a),u=r.add(u,u),c=r.mul(t,u),h=r.mul(i,f),h=r.add(c,h),c=r.sub(d,h),h=r.add(d,h),h=r.mul(c,h),c=r.mul(y,c),u=r.mul(i,u),f=r.mul(t,f),y=r.sub(l,f),y=r.mul(t,y),y=r.add(y,u),u=r.add(l,l),l=r.add(u,l),l=r.add(l,f),l=r.mul(l,y),h=r.add(h,l),f=r.mul(s,a),f=r.add(f,f),l=r.mul(f,y),c=r.sub(c,l),u=r.mul(f,d),u=r.add(u,u),u=r.add(u,u),new g(c,h,u)}add(t){l(t);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=t;let h=r.ZERO,u=r.ZERO,d=r.ZERO;const f=e.a,y=r.mul(e.b,Ge);let p=r.mul(n,s),w=r.mul(i,a),m=r.mul(o,c),b=r.add(n,i),S=r.add(s,a);b=r.mul(b,S),S=r.add(p,w),b=r.sub(b,S),S=r.add(n,o);let A=r.add(s,c);return S=r.mul(S,A),A=r.add(p,m),S=r.sub(S,A),A=r.add(i,o),h=r.add(a,c),A=r.mul(A,h),h=r.add(w,m),A=r.sub(A,h),d=r.mul(f,S),h=r.mul(y,m),d=r.add(h,d),h=r.sub(w,d),d=r.add(w,d),u=r.mul(h,d),w=r.add(p,p),w=r.add(w,p),m=r.mul(f,m),S=r.mul(y,S),w=r.add(w,m),m=r.sub(p,m),m=r.mul(f,m),S=r.add(S,m),p=r.mul(w,S),u=r.add(u,p),p=r.mul(A,S),h=r.mul(b,h),h=r.sub(h,p),p=r.mul(b,w),d=r.mul(A,d),d=r.add(d,p),new g(h,u,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return w.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:i}=e;re("scalar",t,$e,i);const o=g.ZERO;if(t===$e)return o;if(this.is0()||t===qe)return this;if(!n||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,t,g.normalizeZ);let{k1neg:s,k1:a,k2neg:c,k2:h}=n.splitScalar(t),u=o,l=o,d=this;for(;a>$e||h>$e;)a&qe&&(u=u.add(d)),h&qe&&(l=l.add(d)),d=d.double(),a>>=qe,h>>=qe;return s&&(u=u.negate()),c&&(l=l.negate()),l=new g(r.mul(l.px,n.beta),l.py,l.pz),u.add(l)}multiply(t){const{endo:n,n:i}=e;let o,s;if(re("scalar",t,qe,i),n){const{k1neg:e,k1:i,k2neg:a,k2:c}=n.splitScalar(t);let{p:h,f:u}=this.wNAF(i),{p:l,f:d}=this.wNAF(c);h=w.constTimeNegate(e,h),l=w.constTimeNegate(a,l),l=new g(r.mul(l.px,n.beta),l.py,l.pz),o=h.add(l),s=u.add(d)}else{const{p:e,f:r}=this.wNAF(t);o=e,s=r}return g.normalizeZ([o,s])[0]}multiplyAndAddUnsafe(t,e,r){const n=g.BASE,i=(t,e)=>e!==$e&&e!==qe&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),o=i(this,e).add(i(t,r));return o.is0()?void 0:o}toAffine(t){return d(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===qe)return!0;if(r)return r(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===qe?this:r?r(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return Mt("isCompressed",t),this.assertValidity(),i(g,this,t)}toHex(t=!0){return Mt("isCompressed",t),Gt(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,r.ONE),g.ZERO=new g(r.ZERO,r.ONE,r.ZERO);const{endo:y,nBitLength:p}=e,w=(m=g,b=y?Math.ceil(p/2):p,{constTimeNegate:ve,hasPrecomputes:t=>1!==De(t),unsafeLadder(t,e,r=m.ZERO){let n=t;for(;e>Te;)e&Ie&&(r=r.add(n)),n=n.double(),e>>=Ie;return r},precomputeWindow(t,e){const{windows:r,windowSize:n}=Ue(e,b),i=[];let o=t,s=o;for(let t=0;t<r;t++){s=o,i.push(s);for(let t=1;t<n;t++)s=s.add(o),i.push(s);o=s.double()}return i},wNAF(t,e,r){let n=m.ZERO,i=m.BASE;const o=Ue(t,b);for(let t=0;t<o.windows;t++){const{nextN:s,offset:a,isZero:c,isNeg:h,isNegF:u,offsetF:l}=Ce(r,t,o);r=s,c?i=i.add(ve(u,e[l])):n=n.add(ve(h,e[a]))}return{p:n,f:i}},wNAFUnsafe(t,e,r,n=m.ZERO){const i=Ue(t,b);for(let t=0;t<i.windows&&r!==Te;t++){const{nextN:o,offset:s,isZero:a,isNeg:c}=Ce(r,t,i);if(r=o,!a){const t=e[s];n=n.add(c?t.negate():t)}}return n},getPrecomputes(t,e,r){let n=He.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&He.set(e,r(n))),n},wNAFCached(t,e,r){const n=De(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)},wNAFCachedUnsafe(t,e,r,n){const i=De(t);return 1===i?this.unsafeLadder(t,e,n):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),e,n)},setWindowSize(t,e){_e(e,b),Pe.set(t,e),He.delete(t)}});var m,b;return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:u,weierstrassEquation:s,isWithinCurveOrder:function(t){return ee(t,qe,e.n)}}}({...e,toBytes(t,e,n){const i=e.toAffine(),o=r.toBytes(i.x),s=Qt;return Mt("isCompressed",n),n?s(Uint8Array.from([e.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],i=t.subarray(1);if(e!==s||2!==n&&3!==n){if(e===a&&4===n)return{x:r.fromBytes(i.subarray(0,r.BYTES)),y:r.fromBytes(i.subarray(r.BYTES,2*r.BYTES))};throw new Error("invalid Point, expected length of "+s+", or uncompressed "+a+", got "+e)}{const t=Yt(i);if(!ee(t,qe,r.ORDER))throw new Error("Point is not on curve");const e=d(t);let o;try{o=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~n)!=((o&qe)===qe)&&(o=r.neg(o)),{x:t,y:o}}}});function g(t){return t>n>>qe}const y=(t,e,r)=>Yt(t.slice(e,r));class p{constructor(t,e,r){re("r",t,qe,n),re("s",e,qe,n),this.r=t,this.s=e,null!=r&&(this.recovery=r),Object.freeze(this)}static fromCompact(t){const e=i;return t=Xt("compactSignature",t,2*e),new p(y(t,0,e),y(t,e,2*e))}static fromDER(t){const{r:e,s:r}=Le.toSig(Xt("DER",t));return new p(e,r)}assertValidity(){}addRecoveryBit(t){return new p(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:o}=this,s=S(Xt("msgHash",t));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const a=2===o||3===o?n+e.n:n;if(a>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=1&o?"03":"02",d=u.fromHex(l+Fe(a,r.BYTES)),f=h(a),g=c(-s*f),y=c(i*f),p=u.BASE.multiplyAndAddUnsafe(d,g,y);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Vt(this.toDERHex())}toDERHex(){return Le.hexFromSig(this)}toCompactRawBytes(){return Vt(this.toCompactHex())}toCompactHex(){const t=i;return Fe(this.r,t)+Fe(this.s,t)}}const w={isValidPrivateKey(t){try{return l(t),!0}catch(t){return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const t=xe(e.n);return function(t,e,r=!1){const n=t.length,i=Re(e),o=xe(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const s=pe(r?zt(t):Yt(t),e-ue)+ue;return r?Wt(s,i):Zt(s,i)}(e.randomBytes(t),e.n)},precompute:(t=8,e=u.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function m(t){if("bigint"==typeof t)return!1;if(t instanceof u)return!0;const n=Xt("key",t).length,o=r.BYTES,s=o+1,a=2*o+1;return e.allowedPrivateKeyLengths||i===s?void 0:n===s||n===a}const b=e.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=Yt(t),r=8*t.length-o;return r>0?e>>BigInt(r):e},S=e.bits2int_modN||function(t){return c(b(t))},A=ne(o);function E(t){return re("num < 2^"+o,t,$e,A),Zt(t,i)}const B={lowS:e.lowS,prehash:!1},O={lowS:e.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return u.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(!0===m(t))throw new Error("first arg must be private key");if(!1===m(e))throw new Error("second arg must be public key");return u.fromHex(e).multiply(l(t)).toRawBytes(r)},sign:function(t,n,i=B){const{seed:o,k2sig:s}=function(t,n,i=B){if(["recovered","canonical"].some(t=>t in i))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:s}=e;let{lowS:a,prehash:d,extraEntropy:y}=i;null==a&&(a=!0),t=Xt("msgHash",t),Ke(i),d&&(t=Xt("prehashed msgHash",o(t)));const w=S(t),m=l(n),A=[E(m),E(w)];if(null!=y&&!1!==y){const t=!0===y?s(r.BYTES):y;A.push(Xt("extraEntropy",t))}const O=Qt(...A),N=w;return{seed:O,k2sig:function(t){const e=b(t);if(!f(e))return;const r=h(e),n=u.BASE.multiply(e).toAffine(),i=c(n.x);if(i===$e)return;const o=c(r*c(N+i*m));if(o===$e)return;let s=(n.x===i?0:2)|Number(n.y&qe),l=o;return a&&g(o)&&(l=function(t){return g(t)?c(-t):t}(o),s^=1),new p(i,l,s)}}}(t,n,i),a=e;return function(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=ie(t),i=ie(t),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...t)=>r(i,n,...t),c=(t=ie(0))=>{i=a(oe([0]),t),n=a(),0!==t.length&&(i=a(oe([1]),t),n=a())},h=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return Qt(...r)};return(t,e)=>{let r;for(s(),c(t);!(r=e(h()));)c();return s(),r}}(a.hash.outputLen,a.nByteLength,a.hmac)(o,s)},verify:function(t,r,n,i=O){const o=t;r=Xt("msgHash",r),n=Xt("publicKey",n);const{lowS:s,prehash:a,format:l}=i;if(Ke(i),"strict"in i)throw new Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw new Error("format must be compact or der");const d="string"==typeof o||kt(o),f=!d&&!l&&"object"==typeof o&&null!==o&&"bigint"==typeof o.r&&"bigint"==typeof o.s;if(!d&&!f)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,y;try{if(f&&(g=new p(o.r,o.s)),d){try{"compact"!==l&&(g=p.fromDER(o))}catch(t){if(!(t instanceof Le.Err))throw t}g||"der"===l||(g=p.fromCompact(o))}y=u.fromHex(n)}catch(t){return!1}if(!g)return!1;if(s&&g.hasHighS())return!1;a&&(r=e.hash(r));const{r:w,s:m}=g,b=S(r),A=h(m),E=c(b*A),B=c(w*A),N=u.BASE.multiplyAndAddUnsafe(y,E,B)?.toAffine();return!!N&&c(N.x)===w},ProjectivePoint:u,Signature:p,utils:w}}function Ye(t){return{hash:t,hmac:(e,...r)=>Pt(t,e,function(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];a(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}(...r)),randomBytes:b}}const ze=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ze=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),We=BigInt(0),Xe=BigInt(1),Qe=BigInt(2),tr=(t,e)=>(t+e/Qe)/e;const er=Ne(ze,void 0,void 0,{sqrt:function(t){const e=ze,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),h=t*t*t%e,u=h*h*t%e,l=we(u,r,e)*u%e,d=we(l,r,e)*u%e,f=we(d,Qe,e)*h%e,g=we(f,i,e)*f%e,y=we(g,o,e)*g%e,p=we(y,a,e)*y%e,w=we(p,c,e)*p%e,m=we(w,a,e)*y%e,b=we(m,r,e)*u%e,S=we(b,s,e)*g%e,A=we(S,n,e)*h%e,E=we(A,Qe,e);if(!er.eql(er.sqr(E),t))throw new Error("Cannot find square root");return E}}),rr=function(t,e){const r=e=>Ve({...t,...Ye(e)});return{...r(e),create:r}}({a:We,b:BigInt(7),Fp:er,n:Ze,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=Ze,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Xe*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=tr(o*t,e),c=tr(-n*t,e);let h=pe(t-a*r-c*i,e),u=pe(-a*n-c*o,e);const l=h>s,d=u>s;if(l&&(h=e-h),d&&(u=e-u),h>s||u>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:h,k2neg:d,k2:u}}}},wt);class nr{privateKey;_publicKey;constructor(t){this.privateKey=t,this.privateKey=new Uint8Array(t),this._publicKey=rr.getPublicKey(this.privateKey,!0)}get publicKey(){return new Uint8Array(this._publicKey)}get algorithm(){return"secp256k1"}static generatePrivateKey(){return rr.utils.randomPrivateKey()}static async createFromSecret(t,e){const r=new It(Et.SHA256);r.update(t),e&&r.update(e);const n=await r.digest();return new nr(n.data)}static verifySignatureWithRecoveredPublicKey(t,e){const r=rr.Signature.fromCompact(e.encode()).recoverPublicKey(t).toRawBytes();return nr.verifyWithPublicKey(t,e.bytes,r)}static verifyWithPublicKey(t,e,r){return Promise.resolve(rr.verify(e,t,r,{format:"compact"}))}verify(t,e){return nr.verifyWithPublicKey(t,e.bytes,this._publicKey)}sign(t){const e=rr.sign(t,this.privateKey);return Promise.resolve(new Ct(e.toCompactRawBytes(),e.recovery))}}function ir(t,...e){if(0===t.length)return"";let r=t[0].split("\n");if(0!==r.shift()?.length)throw new Error("First line must be empty");const n=r[0].length-r[0].trimStart().length,i=[];for(let o=0;o<t.length;o++){i.push(`${i.pop()||""}${r[0].slice(Math.min(r[0].length-r[0].trim().length,n))}`);for(let t=1;t<r.length;t++)i.push(r[t].slice(n));const s=i.pop(),a=s.length-s.trimStart().length,c=o<e.length?String(e[o]).split("\n"):[""];i.push(`${s}${c[0]}`);for(let t=1;t<c.length;t++)i.push(`${" ".repeat(a)}${c[t]}`);r=o+1<t.length?t[o+1].split("\n"):[]}return i.join("\n")}class or{algorithm;_publicKey;signature;stateHash;constructor(t,e,r,n){this.algorithm=t,this._publicKey=e,this.signature=r,this.stateHash=n,this._publicKey=new Uint8Array(e)}get publicKey(){return new Uint8Array(this._publicKey)}static async create(t,e,r){return new or(t.algorithm,t.publicKey,await t.sign(e.imprint),r)}static fromJSON(t){if(!or.isJSON(t))throw new Error("Parsing authenticator dto failed.");return new or(t.algorithm,S.decode(t.publicKey),Ct.fromJSON(t.signature),Rt.fromJSON(t.stateHash))}static isJSON(t){return"object"==typeof t&&null!==t&&"publicKey"in t&&"string"==typeof t.publicKey&&"algorithm"in t&&"string"==typeof t.algorithm&&"signature"in t&&"string"==typeof t.signature&&"stateHash"in t&&"string"==typeof t.stateHash}static fromCBOR(t){const e=Nt.readArray(t);return new or(Nt.readTextString(e[0]),Nt.readByteString(e[1]),Ct.decode(Nt.readByteString(e[2])),Rt.fromImprint(Nt.readByteString(e[3])))}toCBOR(){return A.encodeArray([A.encodeTextString(this.algorithm),A.encodeByteString(this.publicKey),A.encodeByteString(this.signature.encode()),A.encodeByteString(this.stateHash.imprint)])}toJSON(){return{algorithm:this.algorithm,publicKey:S.encode(this.publicKey),signature:this.signature.toJSON(),stateHash:this.stateHash.toJSON()}}verify(t){return nr.verifyWithPublicKey(t.imprint,this.signature.bytes,this.publicKey)}calculateRequestId(){return Ut.create(this._publicKey,this.stateHash)}toString(){return ir`
      Authenticator
        Public Key: ${S.encode(this._publicKey)}
        Signature Algorithm: ${this.algorithm}
        Signature: ${this.signature.toString()}
        State Hash: ${this.stateHash.toString()}`}}class sr{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static async create(t,e){const r=await new It(Et.SHA256).update(t.toCBOR()).update(e.imprint).digest();return new sr(r.imprint)}equals(t){return!!ArrayBuffer.isView(t)&&S.encode(this.bytes)===S.encode(new Uint8Array(t.buffer,t.byteOffset,t.byteLength))}toString(){return`LeafValue[${S.encode(this.bytes)}]`}}class ar{static decode(t,e,r){if(e=e??0,r=r??t.length,e<0||r<0||e+r>t.length)throw new Error("Index out of bounds");let n=0n;for(let i=0;i<r;++i)n=n<<8n|BigInt(255&t[e+i]);return n}static encode(t){const e=[];for(let r=t;r>0n;r>>=8n)e.unshift(Number(0xffn&r));return new Uint8Array(e)}}class cr{path;_value;hash;constructor(t,e,r){this.path=e,this._value=r,this._value=new Uint8Array(r),this.hash=new It(t).update(ar.encode(e)).update(this._value).digest()}get value(){return new Uint8Array(this._value)}calculateHash(){return this.hash}toString(){return ir`
      Branch[${this.path.toString(2)}]
        Value: ${S.encode(this._value)}`}}class hr{_value;constructor(t){this._value=t,this._value=t?new Uint8Array(t):null}get value(){return this._value?new Uint8Array(this._value):null}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Parsing merkle tree path step branch failed.");const e=t.at(0);return new hr(e?S.decode(e):null)}static fromCBOR(t){const e=Nt.readArray(t);return new hr(Nt.readOptional(e[0],Nt.readByteString))}toCBOR(){return A.encodeArray([A.encodeOptional(this._value,A.encodeByteString)])}toJSON(){return this._value?[S.encode(this._value)]:[]}toString(){return`MerkleTreePathStepBranch[${this._value?S.encode(this._value):"null"}]`}}class ur{path;sibling;branch;constructor(t,e,r){this.path=t,this.sibling=e,this.branch=r}static async createWithoutBranch(t,e){return new ur(t,await(e?.calculateHash())??null,null)}static async create(t,e,r){const n=await(r?.calculateHash());if(null==e)return new ur(t,n??null,new hr(null));if(e instanceof cr)return new ur(t,n??null,new hr(e.value));const i=await e.calculateChildrenHash();return new ur(t,n??null,new hr(i.data))}static isJSON(t){return"object"==typeof t&&null!==t&&"path"in t&&"string"==typeof t.path&&"sibling"in t&&"branch"in t}static fromJSON(t){if(!ur.isJSON(t))throw new Error("Parsing merkle tree path step failed.");return new ur(BigInt(t.path),null==t.sibling?null:Rt.fromJSON(t.sibling),null!=t.branch?hr.fromJSON(t.branch):null)}static fromCBOR(t){const e=Nt.readArray(t);return new ur(ar.decode(Nt.readByteString(e[0])),Nt.readOptional(e[1],Rt.fromCBOR),Nt.readOptional(e[2],hr.fromCBOR))}toCBOR(){return A.encodeArray([A.encodeByteString(ar.encode(this.path)),this.sibling?.toCBOR()??A.encodeNull(),this.branch?.toCBOR()??A.encodeNull()])}toJSON(){return{branch:this.branch?.toJSON()??null,path:this.path.toString(),sibling:this.sibling?.toJSON()??null}}toString(){return ir`
      Merkle Tree Path Step
        Path: ${this.path.toString(2)}
        Branch: ${this.branch?.toString()??"null"}
        Sibling: ${this.sibling?.toString()??"null"}`}}class lr{isPathValid;isPathIncluded;result;constructor(t,e){this.isPathValid=t,this.isPathIncluded=e,this.result=t&&e}}class dr{root;steps;constructor(t,e){this.root=t,this.steps=e}static fromJSON(t){if(!dr.isJSON(t))throw new Error("Parsing merkle tree path json failed.");return new dr(Rt.fromJSON(t.root),t.steps.map(t=>ur.fromJSON(t)))}static isJSON(t){return"object"==typeof t&&null!==t&&"root"in t&&"string"==typeof t.root&&"steps"in t&&Array.isArray(t.steps)}static fromCBOR(t){const e=Nt.readArray(t),r=Nt.readArray(e[1]);return new dr(Rt.fromCBOR(e[0]),r.map(t=>ur.fromCBOR(t)))}toCBOR(){return A.encodeArray([this.root.toCBOR(),A.encodeArray(this.steps.map(t=>t.toCBOR()))])}toJSON(){return{root:this.root.toJSON(),steps:this.steps.map(t=>t.toJSON())}}async verify(t){let e=1n,r=null;for(let t=0;t<this.steps.length;t++){const n=this.steps[t];let i;if(null===n.branch)i=new Uint8Array(1);else{const o=0===t?n.branch.value:r?.data;i=(await new It(Et.SHA256).update(ar.encode(n.path)).update(o??new Uint8Array(1)).digest()).data;const s=BigInt(n.path.toString(2).length-1);e=e<<s|n.path&(1n<<s)-1n}const o=n.sibling?.data??new Uint8Array(1),s=1n&n.path;r=await new It(Et.SHA256).update(s?o:i).update(s?i:o).digest()}return new lr(!!r&&this.root.equals(r),t===e)}toString(){return ir`
      Merkle Tree Path
        Root: ${this.root.toString()} 
        Steps: [
          ${this.steps.map(t=>t?.toString()??"null").join("\n")}
        ]`}}var fr;!function(t){t.NOT_AUTHENTICATED="NOT_AUTHENTICATED",t.PATH_NOT_INCLUDED="PATH_NOT_INCLUDED",t.PATH_INVALID="PATH_INVALID",t.OK="OK"}(fr||(fr={}));class gr{merkleTreePath;authenticator;transactionHash;constructor(t,e,r){if(this.merkleTreePath=t,this.authenticator=e,this.transactionHash=r,!this.authenticator!=!this.transactionHash)throw new Error("Authenticator and transaction hash must be both set or both null.")}static isJSON(t){return"object"==typeof t&&null!==t&&"merkleTreePath"in t}static fromJSON(t){if(!gr.isJSON(t))throw new Error("Parsing inclusion proof json failed.");return new gr(dr.fromJSON(t.merkleTreePath),t.authenticator?or.fromJSON(t.authenticator):null,t.transactionHash?Rt.fromJSON(t.transactionHash):null)}static fromCBOR(t){const e=Nt.readArray(t),r=Nt.readOptional(e[1],or.fromCBOR),n=Nt.readOptional(e[2],Rt.fromCBOR);return new gr(dr.fromCBOR(e[0]),r,n)}toJSON(){return{authenticator:this.authenticator?.toJSON()??null,merkleTreePath:this.merkleTreePath.toJSON(),transactionHash:this.transactionHash?.toJSON()??null}}toCBOR(){return A.encodeArray([this.merkleTreePath.toCBOR(),this.authenticator?.toCBOR()??A.encodeNull(),this.transactionHash?.toCBOR()??A.encodeNull()])}async verify(t){if(this.authenticator&&this.transactionHash){if(!await this.authenticator.verify(this.transactionHash))return fr.NOT_AUTHENTICATED;if(!(await sr.create(this.authenticator,this.transactionHash)).equals(this.merkleTreePath.steps.at(0)?.branch?.value))return fr.PATH_NOT_INCLUDED}const e=await this.merkleTreePath.verify(t);return e.isPathValid?e.isPathIncluded?fr.OK:fr.PATH_NOT_INCLUDED:fr.PATH_INVALID}toString(){return ir`
      Inclusion Proof
        ${this.merkleTreePath.toString()}
        ${this.authenticator?.toString()}
        Transaction Hash: ${this.transactionHash?.toString()??null}`}}const yr={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let pr;const wr=new Uint8Array(16),mr=[];for(let t=0;t<256;++t)mr.push((t+256).toString(16).slice(1));const br=function(t,e,r){if(yr.randomUUID&&!e&&!t)return yr.randomUUID();const n=(t=t||{}).random??t.rng?.()??function(){if(!pr){if("undefined"==typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");pr=crypto.getRandomValues.bind(crypto)}return pr(wr)}();if(n.length<16)throw new Error("Random bytes length must be >= 16");if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,e){if((r=r||0)<0||r+16>e.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let t=0;t<16;++t)e[r+t]=n[t];return e}return function(t,e=0){return(mr[t[e+0]]+mr[t[e+1]]+mr[t[e+2]]+mr[t[e+3]]+"-"+mr[t[e+4]]+mr[t[e+5]]+"-"+mr[t[e+6]]+mr[t[e+7]]+"-"+mr[t[e+8]]+mr[t[e+9]]+"-"+mr[t[e+10]]+mr[t[e+11]]+mr[t[e+12]]+mr[t[e+13]]+mr[t[e+14]]+mr[t[e+15]]).toLowerCase()}(n)};class Sr{code;message;name="JsonRpcError";constructor({code:t,message:e}){this.code=t,this.message=e}toString(){return`{ code: ${this.code}, message: ${this.message} }`}}class Ar{status;message;name="JsonRpcNetworkError";constructor(t,e){this.status=t,this.message=e}}class Er{url;constructor(t){this.url=t}async request(t,e){const r=await fetch(this.url,{body:JSON.stringify({id:br(),jsonrpc:"2.0",method:t,params:e}),headers:{"Content-Type":"application/json"},method:"POST"});if(!r.ok)throw new Ar(r.status,await r.text());const n=await r.json();if(n.error)throw new Sr(n.error);return n.result}}var Br,Or;!function(t){t.SUCCESS="SUCCESS",t.AUTHENTICATOR_VERIFICATION_FAILED="AUTHENTICATOR_VERIFICATION_FAILED",t.REQUEST_ID_MISMATCH="REQUEST_ID_MISMATCH",t.REQUEST_ID_EXISTS="REQUEST_ID_EXISTS"}(Br||(Br={}));class Nr{status;constructor(t){this.status=t}static fromDto(t){if(!Nr.isDto(t))throw new Error("Parsing submit state transition response failed.");return new Nr(t.status)}static isDto(t){return"object"==typeof t&&null!==t&&"status"in t&&"string"==typeof t.status}}class Rr{transport;constructor(t){this.transport=new Er(t)}async submitTransaction(t,e,r){const n={authenticator:r.toJSON(),requestId:t.toJSON(),transactionHash:e.toJSON()};return await this.transport.request("submit_commitment",n),new Nr(Br.SUCCESS)}async getInclusionProof(t,e){const r={blockNum:e?.toString(),requestId:t.toJSON()};return gr.fromJSON(await this.transport.request("get_inclusion_proof",r))}getNoDeletionProof(t){const e={requestId:t.toJSON()};return this.transport.request("get_no_deletion_proof",e)}}!function(t){t.MASKED="MASKED",t.UNMASKED="UNMASKED",t.BURN="BURN"}(Or||(Or={}));const xr=Or.BURN;class Tr{reference;hash;_nonce;type=xr;constructor(t,e,r){this.reference=t,this.hash=e,this._nonce=r}get nonce(){return new Uint8Array(this._nonce)}static async create(t,e,r){const n=await Tr.calculateReference(e),i=await Tr.calculateHash(n,t,r);return new Tr(n,i,r)}static async fromJSON(t,e,r){if(!Tr.isJSON(r))throw new Error("Invalid burn predicate json");const n=S.decode(r.nonce),i=await Tr.calculateReference(e),o=await Tr.calculateHash(i,t,n);return new Tr(i,o,n)}static calculateReference(t){return new It(Et.SHA256).update(A.encodeArray([A.encodeTextString(xr),t.toCBOR()])).digest()}static isJSON(t){return"object"==typeof t&&null!==t&&"nonce"in t&&"string"==typeof t.nonce}static calculateHash(t,e,r){return new It(Et.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR(),A.encodeByteString(r)])).digest()}toJSON(){return{nonce:S.encode(this._nonce),type:this.type}}toCBOR(){return A.encodeArray([A.encodeTextString(this.type)])}verify(){return Promise.resolve(!1)}toString(){return ir`
          Predicate[${this.type}]:
            Hash: ${this.hash.toString()}`}isOwner(){return Promise.resolve(!1)}}class Ir{type;_publicKey;algorithm;hashAlgorithm;_nonce;reference;hash;constructor(t,e,r,n,i,o,s){this.type=t,this._publicKey=e,this.algorithm=r,this.hashAlgorithm=n,this._nonce=i,this.reference=o,this.hash=s,this._publicKey=new Uint8Array(e),this._nonce=new Uint8Array(i)}get publicKey(){return this._publicKey}get nonce(){return this._nonce}static isJSON(t){return"object"==typeof t&&null!==t&&"publicKey"in t&&"string"==typeof t.publicKey&&"algorithm"in t&&"string"==typeof t.algorithm&&"hashAlgorithm"in t&&!!Et[t.hashAlgorithm]&&"nonce"in t&&"string"==typeof t.nonce}toJSON(){return{algorithm:this.algorithm,hashAlgorithm:this.hashAlgorithm,nonce:S.encode(this.nonce),publicKey:S.encode(this.publicKey),type:this.type}}toCBOR(){return A.encodeArray([A.encodeTextString(this.type),A.encodeByteString(this.publicKey),A.encodeTextString(this.algorithm),A.encodeTextString(Et[this.hashAlgorithm]),A.encodeByteString(this.nonce)])}async verify(t){if(!t.inclusionProof.authenticator||!t.inclusionProof.transactionHash)return!1;if(S.encode(t.inclusionProof.authenticator.publicKey)!==S.encode(this.publicKey)||!t.inclusionProof.authenticator.stateHash.equals(t.data.sourceState.hash))return!1;if(!await t.inclusionProof.authenticator.verify(t.data.hash))return!1;const e=await Ut.create(this.publicKey,t.data.sourceState.hash);return await t.inclusionProof.verify(e.toBigInt())===fr.OK}toString(){return ir`
          Predicate[${this.type}]:
            PublicKey: ${S.encode(this.publicKey)}
            Algorithm: ${this.algorithm}
            Hash Algorithm: ${Et[this.hashAlgorithm]}
            Nonce: ${S.encode(this.nonce)}
            Hash: ${this.hash.toString()}`}isOwner(t){return Promise.resolve(S.encode(t)===S.encode(this.publicKey))}}const vr=Or.MASKED;class _r extends Ir{constructor(t,e,r,n,i,o){super(vr,t,e,r,n,i,o)}static async create(t,e,r,n,i){const o=await _r.calculateReference(e,r.algorithm,r.publicKey,n,i),s=await _r.calculateHash(o,t);return new _r(r.publicKey,r.algorithm,n,i,o,s)}static async fromJSON(t,e,r){if(!Ir.isJSON(r))throw new Error("Invalid one time address predicate json");const n=S.decode(r.publicKey),i=S.decode(r.nonce),o=await _r.calculateReference(e,r.algorithm,n,r.hashAlgorithm,i),s=await _r.calculateHash(o,t);return new _r(n,r.algorithm,r.hashAlgorithm,i,o,s)}static calculateReference(t,e,r,n,i){return new It(Et.SHA256).update(A.encodeArray([A.encodeTextString(vr),t.toCBOR(),A.encodeTextString(e),A.encodeTextString(Et[n]),A.encodeByteString(r),A.encodeByteString(i)])).digest()}static calculateHash(t,e){return new It(Et.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR()])).digest()}}const Ur=Or.UNMASKED;class Cr extends Ir{constructor(t,e,r,n,i,o){super(Ur,t,e,r,n,i,o)}static async create(t,e,r,n,i){const o=await Cr.calculateReference(e,r.algorithm,r.publicKey,n),s=await new It(Et.SHA256).update(i).digest(),a=await r.sign(s.imprint),c=await Cr.calculateHash(o,t,a.bytes);return new Cr(r.publicKey,r.algorithm,n,a.bytes,o,c)}static async fromJSON(t,e,r){if(!Ir.isJSON(r))throw new Error("Invalid one time address predicate json");const n=S.decode(r.publicKey),i=await Cr.calculateReference(e,r.algorithm,n,r.hashAlgorithm),o=S.decode(r.nonce),s=await Cr.calculateHash(i,t,o);return new Cr(n,r.algorithm,r.hashAlgorithm,o,i,s)}static calculateReference(t,e,r,n){return new It(Et.SHA256).update(A.encodeArray([A.encodeTextString(Ur),t.toCBOR(),A.encodeTextString(e),A.encodeTextString(Et[n]),A.encodeByteString(r)])).digest()}static calculateHash(t,e,r){return new It(Et.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR(),A.encodeByteString(r)])).digest()}}class Hr{create(t,e,r){switch(r.type){case Or.BURN:return Tr.fromJSON(t,e,r);case Or.MASKED:return _r.fromJSON(t,e,r);case Or.UNMASKED:return Cr.fromJSON(t,e,r);default:throw new Error(`Unknown predicate type: ${r.type}`)}}}class Pr{static decode(){return Promise.resolve(new Pr)}toJSON(){throw new Error("toJSON method is not implemented.")}toCBOR(){throw new Error("toCBOR method is not implemented.")}}const Dr="2.0";class Jr{id;type;data;coins;state;_transactions;_nametagTokens;version;constructor(t,e,r,n,i,o,s=[],a=Dr){this.id=t,this.type=e,this.data=r,this.coins=n,this.state=i,this._transactions=o,this._nametagTokens=s,this.version=a,this._nametagTokens=[...s],this._transactions=[...o]}get nametagTokens(){return[...this._nametagTokens]}get transactions(){return[...this._transactions]}toJSON(){return{coins:this.coins?.toJSON()??null,data:this.data.toJSON(),id:this.id.toJSON(),nametagTokens:this.nametagTokens.map(t=>t.toJSON()),state:this.state.toJSON(),transactions:this.transactions.map(t=>t.toJSON()),type:this.type.toJSON(),version:this.version}}toCBOR(){return A.encodeArray([this.id.toCBOR(),this.type.toCBOR(),this.data.toCBOR(),this.coins?.toCBOR()??A.encodeNull(),this.state.toCBOR(),A.encodeArray(this.transactions.map(t=>t.toCBOR())),A.encodeArray(this.nametagTokens.map(t=>t.toCBOR())),A.encodeTextString(this.version)])}toString(){return ir`
        Token[${this.version}]:
          Id: ${this.id.toString()}
          Type: ${this.type.toString()}
          Data: 
            ${this.data.toString()}
          Coins:
            ${this.coins?.toString()??null}
          State:
            ${this.state.toString()}
          Transactions: [
            ${this.transactions.map(t=>t.toString()).join("\n")}
          ]
          Nametag Tokens: [ 
            ${this.nametagTokens.map(t=>t.toString()).join("\n")}
          ]
      `}}class kr{requestId;transactionData;authenticator;constructor(t,e,r){this.requestId=t,this.transactionData=e,this.authenticator=r}}class Kr{hash;sourceState;recipient;_salt;dataHash;reason;constructor(t,e,r,n,i,o){this.hash=t,this.sourceState=e,this.recipient=r,this._salt=n,this.dataHash=i,this.reason=o,this._salt=new Uint8Array(n)}get salt(){return new Uint8Array(this._salt)}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e,r,n,i,o,s,a,c){const h=await new It(Et.SHA256).update(r.toCBOR()).digest();return new Kr(await new It(Et.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR(),h.toCBOR(),a?.toCBOR()??A.encodeNull(),n?.toCBOR()??A.encodeNull(),A.encodeTextString(o),A.encodeByteString(s),c?.toCBOR()??A.encodeNull()])).digest(),i,o,s,a,c)}toJSON(){return{dataHash:this.dataHash?.toJSON()??null,reason:this.reason?.toJSON()??null,recipient:this.recipient,salt:S.encode(this.salt)}}toCBOR(){return A.encodeArray([A.encodeTextString(this.recipient),A.encodeByteString(this.salt),this.dataHash?.toCBOR()??A.encodeNull(),this.reason?.toCBOR()??A.encodeNull()])}toString(){return ir`
      MintTransactionData:
        Recipient: ${this.recipient}
        Salt: ${S.encode(this.salt)}
        Data: ${this.dataHash?.toString()??null}
        Reason: ${this.reason?.toString()??null}
        Hash: ${this.hash.toString()}`}}class Mr{data;inclusionProof;constructor(t,e){this.data=t,this.inclusionProof=e}toJSON(){return{data:this.data.toJSON(),inclusionProof:this.inclusionProof.toJSON()}}toCBOR(){return A.encodeArray([this.data.toCBOR(),this.inclusionProof.toCBOR()])}async containsData(t){return this.data.dataHash?!!t&&(await new It(this.data.dataHash.algorithm).update(t).digest()).equals(this.data.dataHash):!t}toString(){return ir`
        Transaction:
          ${this.data.toString()}
          ${this.inclusionProof.toString()}`}}const Lr=S.decode("9e82002c144d7c5796c50f6db50a0c7bbd7f717ae3af6c6c71a3e9eba3022730"),Fr=S.decode("495f414d5f554e4956455253414c5f4d494e5445525f464f525f");class $r{client;constructor(t){this.client=t}async submitMintTransaction(t,e,r,n,i,o,s,a){const c=await Ut.createFromImprint(e.encode(),Lr),h=await nr.createFromSecret(Fr,e.encode()),u=await Ut.create(h.publicKey,c.hash),l=await Kr.create(e,r,n,i,c,t.toJSON(),o,s??null,a),d=await or.create(h,l.hash,c.hash),f=await this.client.submitTransaction(u,l.hash,d);if(f.status!==Br.SUCCESS)throw new Error(`Could not submit transaction: ${f.status}`);return new kr(u,l,d)}async submitTransaction(t,e){if(!await t.sourceState.unlockPredicate.isOwner(e.publicKey))throw new Error("Failed to unlock token");const r=await Ut.create(e.publicKey,t.sourceState.hash),n=await or.create(e,t.hash,t.sourceState.hash),i=await this.client.submitTransaction(r,t.hash,n);if(i.status!==Br.SUCCESS)throw new Error(`Could not submit transaction: ${i.status}`);return new kr(r,t,n)}async createTransaction({requestId:t,transactionData:e},r){if(await r.verify(t.toBigInt())!=fr.OK)throw new Error("Inclusion proof verification failed.");if(!r.authenticator||!Et[r.authenticator.stateHash.algorithm])throw new Error("Invalid inclusion proof hash algorithm.");if(!r.transactionHash?.equals(e.hash))throw new Error("Payload hash mismatch");return new Mr(e,r)}async finishTransaction(t,e,r,n=[]){if(!await r.data.sourceState.unlockPredicate.verify(r))throw new Error("Predicate verification failed");if((await vt.create(e.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");const i=[...t.transactions,r];if(!await r.containsData(e.data))throw new Error("State data is not part of transaction.");return new Jr(t.id,t.type,t.data,t.coins,e,i,n)}async getTokenStatus(t,e){const r=await Ut.create(e,t.state.hash);return(await this.client.getInclusionProof(r)).verify(r.toBigInt())}getInclusionProof(t){return this.client.getInclusionProof(t.requestId)}}class qr{_id;constructor(t){this._id=t,this._id=new Uint8Array(t)}static create(t){return new qr(t)}toJSON(){return S.encode(this._id)}toCBOR(){return A.encodeByteString(this._id)}encode(){return new Uint8Array(this._id)}toString(){return`TokenId[${S.encode(this._id)}]`}}class Gr{unlockPredicate;_data;hash;constructor(t,e,r){this.unlockPredicate=t,this._data=e,this.hash=r,this._data=e?new Uint8Array(e):null}get data(){return this._data?new Uint8Array(this._data):null}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e){return new Gr(t,e,await new It(Et.SHA256).update(A.encodeArray([t.hash.toCBOR(),A.encodeOptional(e,A.encodeByteString)])).digest())}toJSON(){return{data:this._data?S.encode(this._data):null,unlockPredicate:this.unlockPredicate.toJSON()}}toCBOR(){return A.encodeArray([this.unlockPredicate.toCBOR(),A.encodeOptional(this._data,A.encodeByteString)])}toString(){return ir`
        TokenState:
          ${this.unlockPredicate.toString()}
          Data: ${this._data?S.encode(this._data):null}
          Hash: ${this.hash.toString()}`}}class jr{_id;constructor(t){this._id=t,this._id=new Uint8Array(t)}static create(t){return new jr(t)}encode(){return new Uint8Array(this._id)}toJSON(){return S.encode(this._id)}toCBOR(){return A.encodeByteString(this._id)}toString(){return`TokenType[${S.encode(this._id)}]`}}class Vr{hash;sourceState;recipient;salt;dataHash;_message;nameTags;constructor(t,e,r,n,i,o,s=[]){this.hash=t,this.sourceState=e,this.recipient=r,this.salt=n,this.dataHash=i,this._message=o,this.nameTags=s,this._message=o?new Uint8Array(o):null,this.nameTags=Array.from(s)}get message(){return this._message?new Uint8Array(this._message):null}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e,r,n,i,o=[]){return new Vr(await new It(Et.SHA256).update(A.encodeArray([t.hash.toCBOR(),n?.toCBOR()??A.encodeNull(),A.encodeTextString(e),A.encodeByteString(r),A.encodeOptional(i,A.encodeByteString)])).digest(),t,e,r,n,i,o)}toJSON(){return{dataHash:this.dataHash?.toJSON()??null,message:this._message?S.encode(this._message):null,nameTags:this.nameTags.map(t=>t.toJSON()),recipient:this.recipient,salt:S.encode(this.salt),sourceState:this.sourceState.toJSON()}}toCBOR(){return A.encodeArray([this.sourceState.toCBOR(),A.encodeTextString(this.recipient),A.encodeByteString(this.salt),this.dataHash?.toCBOR()??A.encodeNull(),this._message?A.encodeByteString(this._message):A.encodeNull(),A.encodeArray(this.nameTags.map(t=>t.toCBOR()))])}toString(){return ir`
      TransactionData:
        ${this.sourceState.toString()}
        Recipient: ${this.recipient.toString()}
        Salt: ${S.encode(this.salt)}
        Data: ${this.dataHash?.toString()??null}
        Message: ${this._message?S.encode(this._message):null}
        NameTags: [
          ${this.nameTags.map(t=>t.toString()).join("\n")}
        ]
        Hash: ${this.hash.toString()}`}}class Yr{data;constructor(t){this.data=t,this.data=new Uint8Array(t)}static fromDto(t){return new Yr(S.decode(t))}toJSON(){return S.encode(this.data)}toCBOR(){return A.encodeByteString(this.data)}}class zr{_coins;constructor(t){this._coins=new Map(t.map(([t,e])=>[t.toJSON(),e]))}get coins(){return Array.from(this._coins.entries()).map(([t,e])=>[Yr.fromDto(t),e])}static fromCBOR(t){const e=[],r=Nt.readArray(t);for(const t of r){const[r,n]=Nt.readArray(t);e.push([Yr.fromDto(Nt.readTextString(r)),Nt.readUnsignedInteger(n)])}return new zr(e)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Invalid coin data JSON format");const e=[];for(const[r,n]of t)e.push([Yr.fromDto(r),BigInt(n)]);return new zr(e)}toCBOR(){return A.encodeArray(Array.from(this._coins.entries()).map(([t,e])=>A.encodeArray([A.encodeTextString(t),A.encodeUnsignedInteger(e)])))}toJSON(){return Array.from(this._coins.entries()).map(([t,e])=>[t,e.toString()])}toString(){return ir`
      FungibleTokenData
        ${Array.from(this._coins.entries()).map(([t,e])=>`${t}: ${e}`).join("\n")}`}}class Zr{predicateFactory;constructor(t){this.predicateFactory=t}async create(t,e){const r=t.version;if(r!==Dr)throw new Error("Cannot parse token. Version mismatch.");const n=qr.create(S.decode(t.id)),i=jr.create(S.decode(t.type)),o=await e(t.data),s=t.coins?zr.fromJSON(t.coins):null,a=await this.createMintTransaction(n,i,o,s,await Ut.createFromImprint(n.encode(),Lr),t.transactions[0]),c=await nr.createFromSecret(Fr,n.encode());if(!await this.verifyMintTransaction(a,c.publicKey))throw new Error("Mint transaction verification failed.");const h=[a];let u=a;for(let e=1;e<t.transactions.length;e++){const r=await this.createTransaction(n,i,t.transactions[e]);if((await vt.create(r.data.sourceState.unlockPredicate.reference)).toJSON()!==u.data.recipient)throw new Error("Recipient address mismatch");if(!await u.containsData(r.data.sourceState.data))throw new Error("State data is not part of transaction.");if(!await r.data.sourceState.unlockPredicate.verify(r))throw new Error("Predicate verification failed");h.push(r),u=r}const l=await Gr.create(await this.predicateFactory.create(n,i,t.state.unlockPredicate),t.state.data?S.decode(t.state.data):null);if(!await u.containsData(l.data))throw new Error("State data is not part of transaction.");if((await vt.create(l.unlockPredicate.reference)).toJSON()!==u.data.recipient)throw new Error("Recipient address mismatch");return new Jr(n,i,o,s,l,h,[],r)}async createMintTransaction(t,e,r,n,i,o){return new Mr(await Kr.create(t,e,r,n,i,o.data.recipient,S.decode(o.data.salt),o.data.dataHash?Rt.fromJSON(o.data.dataHash):null,o.data.reason?this.createMintReason(o.data.reason):null),gr.fromJSON(o.inclusionProof))}createMintReason(t){if("object"!=typeof t||null==t||!("type"in t))throw new Error("MintReason: data is not an object");throw t.type,new Error("NOT IMPLEMENTED")}async createTransaction(t,e,{data:r,inclusionProof:n}){return new Mr(await Vr.create(await Gr.create(await this.predicateFactory.create(t,e,r.sourceState.unlockPredicate),r.sourceState.data?S.decode(r.sourceState.data):null),r.recipient,S.decode(r.salt),r.dataHash?Rt.fromJSON(r.dataHash):null,r.message?S.decode(r.message):null,[]),gr.fromJSON(n))}async verifyMintTransaction(t,e){if(!t.inclusionProof.authenticator||!t.inclusionProof.transactionHash)return!1;if(S.encode(t.inclusionProof.authenticator.publicKey)!==S.encode(e)||!t.inclusionProof.authenticator.stateHash.equals(t.data.sourceState.hash))return!1;if(!await t.inclusionProof.authenticator.verify(t.data.hash))return!1;const r=await Ut.create(e,t.data.sourceState.hash);return await t.inclusionProof.verify(r.toBigInt())===fr.OK}}return n})());