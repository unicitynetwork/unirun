/*! For license information please see unicity-sdk.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.UnicitySDK=e():t.UnicitySDK=e()}(self,()=>(()=>{"use strict";var t,e,r={d:(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},n={};r.r(n),r.d(n,{AddressScheme:()=>t,AggregatorClient:()=>Tr,Authenticator:()=>or,BurnPredicate:()=>xr,CoinId:()=>Vr,Commitment:()=>pn,DataHash:()=>R,DataHasher:()=>vt,DefaultPredicate:()=>_r,DirectAddress:()=>xt,HashAlgorithm:()=>O,HexConverter:()=>b,InclusionProof:()=>yr,InclusionProofVerificationStatus:()=>fr,MINTER_SECRET:()=>wn,MaskedPredicate:()=>Pr,MintTransactionData:()=>Qr,NameTagTokenData:()=>Jr,PredicateJsonFactory:()=>kr,PredicateType:()=>Ir,RequestId:()=>Pt,Signature:()=>Ht,SigningService:()=>ir,StateTransitionClient:()=>mn,SubmitCommitmentStatus:()=>gr,TOKEN_VERSION:()=>gn,Token:()=>yn,TokenCoinData:()=>Yr,TokenFactory:()=>Sn,TokenId:()=>Zr,TokenJsonSerializer:()=>fn,TokenState:()=>Dr,TokenType:()=>Wr,Transaction:()=>en,TransactionData:()=>nn,TransactionJsonSerializer:()=>dn,UnmaskedPredicate:()=>Ur,waitInclusionProof:()=>On}),function(t){t.DIRECT="DIRECT",t.PROXY="PROXY"}(t||(t={}));class i extends Error{}!function(t){t[t.UNSIGNED_INTEGER=0]="UNSIGNED_INTEGER",t[t.NEGATIVE_INTEGER=32]="NEGATIVE_INTEGER",t[t.BYTE_STRING=64]="BYTE_STRING",t[t.TEXT_STRING=96]="TEXT_STRING",t[t.ARRAY=128]="ARRAY",t[t.MAP=160]="MAP",t[t.TAG=192]="TAG",t[t.FLOAT_SIMPLE_BREAK=224]="FLOAT_SIMPLE_BREAK"}(e||(e={}));const s="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function o(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function a(t,...e){if(!((r=t)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw new Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function c(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function h(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function u(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function l(t,e){return t<<32-e|t>>>e}function d(t,e){return t<<e|t>>>32-e>>>0}const f=(()=>"function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex)(),g=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function y(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function p(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}(t)),a(t),t}class w{}function m(t){const e=e=>t().update(p(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function S(t=32){if(s&&"function"==typeof s.getRandomValues)return s.getRandomValues(new Uint8Array(t));if(s&&"function"==typeof s.randomBytes)return Uint8Array.from(s.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}class b{static encode(t){return function(t){if(a(t),f)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=g[t[r]];return e}(t)}static decode(t){return function(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(f)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=y(t.charCodeAt(i)),s=y(t.charCodeAt(i+1));if(void 0===r||void 0===s){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+s}return n}(t)}}class A{static encodeOptional(t,e){return null==t?new Uint8Array([246]):e(t)}static encodeUnsignedInteger(t){if(t<0)throw new i("Only unsigned numbers are allowed.");if(t<24)return new Uint8Array([e.UNSIGNED_INTEGER|Number(t)]);const r=A.getUnsignedIntegerAsPaddedBytes(t);return new Uint8Array([e.UNSIGNED_INTEGER|A.getAdditionalInformationBits(r.length),...r])}static encodeByteString(t){if(t.length<24)return new Uint8Array([e.BYTE_STRING|t.length,...t]);const r=A.getUnsignedIntegerAsPaddedBytes(t.length);return new Uint8Array([e.BYTE_STRING|A.getAdditionalInformationBits(r.length),...r,...t])}static encodeTextString(t){const r=(new TextEncoder).encode(t);if(r.length<24)return new Uint8Array([e.TEXT_STRING|r.length,...r]);const n=A.getUnsignedIntegerAsPaddedBytes(r.length);return new Uint8Array([e.TEXT_STRING|A.getAdditionalInformationBits(n.length),...n,...r])}static encodeArray(t){const r=new Uint8Array(t.reduce((t,e)=>t+e.length,0));let n=0;for(const e of t)r.set(e,n),n+=e.length;if(t.length<24)return new Uint8Array([e.ARRAY|t.length,...r]);const i=A.getUnsignedIntegerAsPaddedBytes(t.length);return new Uint8Array([e.ARRAY|A.getAdditionalInformationBits(i.length),...i,...r])}static encodeMap(t){const r=Array.from(t.entries()).map(([t,e])=>[b.decode(t),e]);r.sort(([t],[e])=>{if(t.length!==e.length)return t.length-e.length;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]-e[r];return 0});const n=r.reduce((t,[e,r])=>t+e.length+r.length,0),i=new Uint8Array(n);let s=0;for(const[t,e]of r)i.set(t,s),s+=t.length,i.set(e,s),s+=e.length;if(t.size<24)return new Uint8Array([e.MAP|t.size,...i]);const o=A.getUnsignedIntegerAsPaddedBytes(t.size);return new Uint8Array([e.MAP|A.getAdditionalInformationBits(o.length),...o,...i])}static encodeTag(t,r){if(t<24)return new Uint8Array([e.TAG|Number(t),...r]);const n=A.getUnsignedIntegerAsPaddedBytes(t);return new Uint8Array([e.TAG|A.getAdditionalInformationBits(n.length),...n,...r])}static encodeBoolean(t){return t?new Uint8Array([245]):new Uint8Array([244])}static encodeNull(){return new Uint8Array([246])}static getAdditionalInformationBits(t){return 24+Math.ceil(Math.log2(t))}static getUnsignedIntegerAsPaddedBytes(t){if(t<0)throw new i("Only unsigned numbers are allowed.");let e;const r=[];for(e=BigInt(t);e>0;e>>=8n)r.push(Number(255n&e));if(r.length>8)throw new i("Number is not unsigned long.");0===r.length&&r.push(0),r.reverse();const n=new Uint8Array(Math.pow(2,Math.ceil(Math.log2(r.length))));return n.set(r,n.length-r.length),n}}var O,B;!function(t){t[t.SHA256=0]="SHA256",t[t.SHA224=1]="SHA224",t[t.SHA384=2]="SHA384",t[t.SHA512=3]="SHA512",t[t.RIPEMD160=4]="RIPEMD160"}(O||(O={}));class E extends Error{constructor(t){super(t),this.name="HashError"}}!function(t){t[t.MAJOR_TYPE=224]="MAJOR_TYPE",t[t.ADDITIONAL_INFORMATION=31]="ADDITIONAL_INFORMATION"}(B||(B={}));class N{static readOptional(t,e){return 246===N.readByte(t,0)?null:e(t)}static readUnsignedInteger(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.UNSIGNED_INTEGER)throw new i("Major type mismatch, expected unsigned integer.");return N.readLength(r,t,0).length}static readNegativeInteger(){throw new i("Not implemented.")}static readByteString(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.BYTE_STRING)throw new i("Major type mismatch, expected byte string.");const{length:n,position:s}=N.readLength(r,t,0);return N.read(t,s,Number(n))}static readTextString(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.TEXT_STRING)throw new i("Major type mismatch, expected text string.");const{length:n,position:s}=N.readLength(r,t,0);return(new TextDecoder).decode(N.read(t,s,Number(n)))}static readArray(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.ARRAY)throw new i("Major type mismatch, expected array.");const n=N.readLength(r,t,0);let s=n.position;const o=[];for(let e=0;e<n.length;e++){const e=N.readRawCbor(t,s);s=e.position,o.push(e.data)}return o}static readMap(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.MAP)throw new i("Major type mismatch, expected map.");const n=N.readLength(r,t,0);let s=n.position;const o=new Map;for(let e=0;e<n.length;e++){const e=N.readRawCbor(t,s);s=e.position;const r=N.readRawCbor(t,s);s=r.position,o.set(b.encode(e.data),r.data)}return o}static readTag(t){const r=N.readByte(t,0)&B.MAJOR_TYPE;if(r!=e.TAG)throw new i("Major type mismatch, expected tag.");const{length:n,position:s}=N.readLength(r,t,0);return{data:N.readRawCbor(t,s).data,tag:n}}static readBoolean(t){const e=N.readByte(t,0);if(245===e)return!0;if(244===e)return!1;throw new i("Type mismatch, expected boolean.")}static readLength(t,r,n){const s=N.readByte(r,n)&B.ADDITIONAL_INFORMATION;if(s<24)return{length:BigInt(s),position:n+1};switch(t){case e.ARRAY:case e.BYTE_STRING:case e.TEXT_STRING:if(31==s)throw new i("Indefinite length array not supported.")}if(s>27)throw new i("Encoded item is not well-formed.");const o=Math.pow(2,s-24);let a=BigInt(0);for(let t=0;t<o;++t)a=a<<8n|BigInt(N.readByte(r,n+1+t));return{length:a,position:n+o+1}}static readRawCbor(t,r){const n=N.readByte(t,r)&B.MAJOR_TYPE,i=N.readLength(n,t,r),s=i.length;let o=i.position;switch(n){case e.BYTE_STRING:case e.TEXT_STRING:o+=Number(s);break;case e.ARRAY:for(let e=0;e<s;e++)o=N.readRawCbor(t,o).position;break;case e.MAP:for(let e=0;e<s;e++)o=N.readRawCbor(t,o).position,o=N.readRawCbor(t,o).position;break;case e.TAG:o=N.readRawCbor(t,o).position}return{data:N.read(t,r,o-r),position:o}}static readByte(t,e){if(t.length<e)throw new i("Premature end of data.");return 255&t[e]}static read(t,e,r){if(t.length<e+r)throw new i("Premature end of data.");return t.subarray(e,e+r)}}class R{algorithm;_data;_imprint;constructor(t,e){this.algorithm=t,this._data=e,this._data=new Uint8Array(e),this._imprint=new Uint8Array(e.length+2),this._imprint.set([(65280&t)>>8,255&t]),this._imprint.set(new Uint8Array(e),2)}get data(){return new Uint8Array(this._data)}get imprint(){return new Uint8Array(this._imprint)}static fromImprint(t){if(t.length<3)throw new E("Imprint must have 2 bytes of algorithm and at least 1 byte of data.");const e=t[0]<<8|t[1];return new R(e,t.subarray(2))}static fromJSON(t){return R.fromImprint(b.decode(t))}static fromCBOR(t){return R.fromImprint(N.readByteString(t))}toJSON(){return b.encode(this._imprint)}toCBOR(){return A.encodeByteString(this._imprint)}equals(t){return b.encode(this._imprint)===b.encode(t._imprint)}toString(){return`[${O[this.algorithm]}]${b.encode(this._data)}`}}function T(t,e,r){return t&e^~t&r}function I(t,e,r){return t&e^t&r^e&r}class v extends w{constructor(t,e,r,n){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.buffer=new Uint8Array(t),this.view=u(this.buffer)}update(t){c(this),a(t=p(t));const{view:e,buffer:r,blockLen:n}=this,i=t.length;for(let s=0;s<i;){const o=Math.min(n-this.pos,i-s);if(o===n){const e=u(t);for(;n<=i-s;s+=n)this.process(e,s);continue}r.set(t.subarray(s,s+o),this.pos),this.pos+=o,s+=o,this.pos===n&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){c(this),function(t,e){a(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:i}=this;let{pos:s}=this;e[s++]=128,h(this.buffer.subarray(s)),this.padOffset>n-s&&(this.process(r,0),s=0);for(let t=s;t<n;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),s=BigInt(4294967295),o=Number(r>>i&s),a=Number(r&s),c=n?4:0,h=n?0:4;t.setUint32(e+c,o,n),t.setUint32(e+h,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const o=u(t),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=l/4,f=this.get();if(d>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<d;t++)o.setUint32(4*t,f[t],i)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:s,pos:o}=this;return t.destroyed=s,t.finished=i,t.length=n,t.pos=o,n%e&&t.buffer.set(r),t}clone(){return this._cloneInto()}}const x=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),_=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),C=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),P=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),H=Uint8Array.from([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),U=(()=>Uint8Array.from(new Array(16).fill(0).map((t,e)=>e)))(),k=(()=>U.map(t=>(9*t+5)%16))(),J=(()=>{const t=[[U],[k]];for(let e=0;e<4;e++)for(let r of t)r.push(r[e].map(t=>H[t]));return t})(),D=(()=>J[0])(),z=(()=>J[1])(),K=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>Uint8Array.from(t)),$=D.map((t,e)=>t.map(t=>K[e][t])),q=z.map((t,e)=>t.map(t=>K[e][t])),M=Uint32Array.from([0,1518500249,1859775393,2400959708,2840853838]),L=Uint32Array.from([1352829926,1548603684,1836072691,2053994217,0]);function F(t,e,r,n){return 0===t?e^r^n:1===t?e&r|~e&n:2===t?(e|~r)^n:3===t?e&n|r&~n:e^(r|~n)}const j=new Uint32Array(16);class G extends v{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:r,h3:n,h4:i}=this;return[t,e,r,n,i]}set(t,e,r,n,i){this.h0=0|t,this.h1=0|e,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(t,e){for(let r=0;r<16;r++,e+=4)j[r]=t.getUint32(e,!0);let r=0|this.h0,n=r,i=0|this.h1,s=i,o=0|this.h2,a=o,c=0|this.h3,h=c,u=0|this.h4,l=u;for(let t=0;t<5;t++){const e=4-t,f=M[t],g=L[t],y=D[t],p=z[t],w=$[t],m=q[t];for(let e=0;e<16;e++){const n=d(r+F(t,i,o,c)+j[y[e]]+f,w[e])+u|0;r=u,u=c,c=0|d(o,10),o=i,i=n}for(let t=0;t<16;t++){const r=d(n+F(e,s,a,h)+j[p[t]]+g,m[t])+l|0;n=l,l=h,h=0|d(a,10),a=s,s=r}}this.set(this.h1+o+h|0,this.h2+c+l|0,this.h3+u+n|0,this.h4+r+s|0,this.h0+i+a|0)}roundClean(){h(j)}destroy(){this.destroyed=!0,h(this.buffer),this.set(0,0,0,0,0)}}const V=m(()=>new G),Y=BigInt(2**32-1),Z=BigInt(32);function W(t,e=!1){return e?{h:Number(t&Y),l:Number(t>>Z&Y)}:{h:0|Number(t>>Z&Y),l:0|Number(t&Y)}}const X=(t,e,r)=>t>>>r,Q=(t,e,r)=>t<<32-r|e>>>r,tt=(t,e,r)=>t>>>r|e<<32-r,et=(t,e,r)=>t<<32-r|e>>>r,rt=(t,e,r)=>t<<64-r|e>>>r-32,nt=(t,e,r)=>t>>>r-32|e<<64-r;function it(t,e,r,n){const i=(e>>>0)+(n>>>0);return{h:t+r+(i/2**32|0)|0,l:0|i}}const st=(t,e,r)=>(t>>>0)+(e>>>0)+(r>>>0),ot=(t,e,r,n)=>e+r+n+(t/2**32|0)|0,at=(t,e,r,n)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0),ct=(t,e,r,n,i)=>e+r+n+i+(t/2**32|0)|0,ht=(t,e,r,n,i)=>(t>>>0)+(e>>>0)+(r>>>0)+(n>>>0)+(i>>>0),ut=(t,e,r,n,i,s)=>e+r+n+i+s+(t/2**32|0)|0,lt=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),dt=new Uint32Array(64);class ft extends v{constructor(t=32){super(64,t,8,!1),this.A=0|x[0],this.B=0|x[1],this.C=0|x[2],this.D=0|x[3],this.E=0|x[4],this.F=0|x[5],this.G=0|x[6],this.H=0|x[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:s,G:o,H:a}=this;return[t,e,r,n,i,s,o,a]}set(t,e,r,n,i,s,o,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|s,this.G=0|o,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)dt[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=dt[t-15],r=dt[t-2],n=l(e,7)^l(e,18)^e>>>3,i=l(r,17)^l(r,19)^r>>>10;dt[t]=i+dt[t-7]+n+dt[t-16]|0}let{A:r,B:n,C:i,D:s,E:o,F:a,G:c,H:h}=this;for(let t=0;t<64;t++){const e=h+(l(o,6)^l(o,11)^l(o,25))+T(o,a,c)+lt[t]+dt[t]|0,u=(l(r,2)^l(r,13)^l(r,22))+I(r,n,i)|0;h=c,c=a,a=o,o=s+e|0,s=i,i=n,n=r,r=e+u|0}r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,s=s+this.D|0,o=o+this.E|0,a=a+this.F|0,c=c+this.G|0,h=h+this.H|0,this.set(r,n,i,s,o,a,c,h)}roundClean(){h(dt)}destroy(){this.set(0,0,0,0,0,0,0,0),h(this.buffer)}}class gt extends ft{constructor(){super(28),this.A=0|_[0],this.B=0|_[1],this.C=0|_[2],this.D=0|_[3],this.E=0|_[4],this.F=0|_[5],this.G=0|_[6],this.H=0|_[7]}}const yt=(()=>function(t,e=!1){const r=t.length;let n=new Uint32Array(r),i=new Uint32Array(r);for(let s=0;s<r;s++){const{h:r,l:o}=W(t[s],e);[n[s],i[s]]=[r,o]}return[n,i]}(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),pt=(()=>yt[0])(),wt=(()=>yt[1])(),mt=new Uint32Array(80),St=new Uint32Array(80);class bt extends v{constructor(t=64){super(128,t,16,!1),this.Ah=0|P[0],this.Al=0|P[1],this.Bh=0|P[2],this.Bl=0|P[3],this.Ch=0|P[4],this.Cl=0|P[5],this.Dh=0|P[6],this.Dl=0|P[7],this.Eh=0|P[8],this.El=0|P[9],this.Fh=0|P[10],this.Fl=0|P[11],this.Gh=0|P[12],this.Gl=0|P[13],this.Hh=0|P[14],this.Hl=0|P[15]}get(){const{Ah:t,Al:e,Bh:r,Bl:n,Ch:i,Cl:s,Dh:o,Dl:a,Eh:c,El:h,Fh:u,Fl:l,Gh:d,Gl:f,Hh:g,Hl:y}=this;return[t,e,r,n,i,s,o,a,c,h,u,l,d,f,g,y]}set(t,e,r,n,i,s,o,a,c,h,u,l,d,f,g,y){this.Ah=0|t,this.Al=0|e,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|s,this.Dh=0|o,this.Dl=0|a,this.Eh=0|c,this.El=0|h,this.Fh=0|u,this.Fl=0|l,this.Gh=0|d,this.Gl=0|f,this.Hh=0|g,this.Hl=0|y}process(t,e){for(let r=0;r<16;r++,e+=4)mt[r]=t.getUint32(e),St[r]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|mt[t-15],r=0|St[t-15],n=tt(e,r,1)^tt(e,r,8)^X(e,0,7),i=et(e,r,1)^et(e,r,8)^Q(e,r,7),s=0|mt[t-2],o=0|St[t-2],a=tt(s,o,19)^rt(s,o,61)^X(s,0,6),c=et(s,o,19)^nt(s,o,61)^Q(s,o,6),h=at(i,c,St[t-7],St[t-16]),u=ct(h,n,a,mt[t-7],mt[t-16]);mt[t]=0|u,St[t]=0|h}let{Ah:r,Al:n,Bh:i,Bl:s,Ch:o,Cl:a,Dh:c,Dl:h,Eh:u,El:l,Fh:d,Fl:f,Gh:g,Gl:y,Hh:p,Hl:w}=this;for(let t=0;t<80;t++){const e=tt(u,l,14)^tt(u,l,18)^rt(u,l,41),m=et(u,l,14)^et(u,l,18)^nt(u,l,41),S=u&d^~u&g,b=ht(w,m,l&f^~l&y,wt[t],St[t]),A=ut(b,p,e,S,pt[t],mt[t]),O=0|b,B=tt(r,n,28)^rt(r,n,34)^rt(r,n,39),E=et(r,n,28)^nt(r,n,34)^nt(r,n,39),N=r&i^r&o^i&o,R=n&s^n&a^s&a;p=0|g,w=0|y,g=0|d,y=0|f,d=0|u,f=0|l,({h:u,l}=it(0|c,0|h,0|A,0|O)),c=0|o,h=0|a,o=0|i,a=0|s,i=0|r,s=0|n;const T=st(O,E,R);r=ot(T,A,B,N),n=0|T}({h:r,l:n}=it(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:s}=it(0|this.Bh,0|this.Bl,0|i,0|s)),({h:o,l:a}=it(0|this.Ch,0|this.Cl,0|o,0|a)),({h:c,l:h}=it(0|this.Dh,0|this.Dl,0|c,0|h)),({h:u,l}=it(0|this.Eh,0|this.El,0|u,0|l)),({h:d,l:f}=it(0|this.Fh,0|this.Fl,0|d,0|f)),({h:g,l:y}=it(0|this.Gh,0|this.Gl,0|g,0|y)),({h:p,l:w}=it(0|this.Hh,0|this.Hl,0|p,0|w)),this.set(r,n,i,s,o,a,c,h,u,l,d,f,g,y,p,w)}roundClean(){h(mt,St)}destroy(){h(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class At extends bt{constructor(){super(48),this.Ah=0|C[0],this.Al=0|C[1],this.Bh=0|C[2],this.Bl=0|C[3],this.Ch=0|C[4],this.Cl=0|C[5],this.Dh=0|C[6],this.Dl=0|C[7],this.Eh=0|C[8],this.El=0|C[9],this.Fh=0|C[10],this.Fl=0|C[11],this.Gh=0|C[12],this.Gl=0|C[13],this.Hh=0|C[14],this.Hl=0|C[15]}}const Ot=m(()=>new ft),Bt=Ot,Et=m(()=>new gt),Nt=m(()=>new bt),Rt=m(()=>new At);class Tt extends Error{constructor(t){super(`Unsupported hash algorithm: ${t}`),this.name="UnsupportedHashAlgorithm"}}const It={[O.RIPEMD160]:V,[O.SHA224]:Et,[O.SHA256]:Bt,[O.SHA384]:Rt,[O.SHA512]:Nt};class vt{algorithm;_messageDigest;constructor(t){if(this.algorithm=t,!It[t])throw new Tt(t);this._messageDigest=It[t].create()}update(t){return this._messageDigest.update(t),this}digest(){return Promise.resolve(new R(this.algorithm,this._messageDigest.digest()))}}class xt{data;checksum;constructor(t,e){this.data=t,this.checksum=e,this.checksum=new Uint8Array(e.slice(0,4))}get scheme(){return t.DIRECT}static async create(t){const e=await new vt(O.SHA256).update(t.toCBOR()).digest();return new xt(t,e.data.slice(0,4))}static async fromJSON(e){const[r,n]=e.split("://");if(r!==t.DIRECT)throw new Error(`Invalid address scheme: expected ${t.DIRECT}, got ${r}`);const i=n.slice(-8),s=await xt.create(R.fromCBOR(b.decode(n.slice(0,-8))));if(b.encode(s.checksum)!==i)throw new Error(`Invalid checksum for DirectAddress: expected ${i}, got ${b.encode(s.checksum)}`);return s}toJSON(){return this.toString()}toCBOR(){return A.encodeTextString(this.toString())}toString(){return`${this.scheme}://${b.encode(this.data.toCBOR())}${b.encode(this.checksum)}`}}class _t{static decode(t,e,r){if(e=e??0,r=r??t.length,e<0||r<0||e+r>t.length)throw new Error("Index out of bounds");let n=0n;for(let i=0;i<r;++i)n=n<<8n|BigInt(255&t[e+i]);return n}static encode(t){const e=[];for(let r=t;r>0n;r>>=8n)e.unshift(Number(0xffn&r));return new Uint8Array(e)}}class Ct{value;constructor(t){this.value=BigInt(`0x01${b.encode(t)}`)}static fromDataHash(t){return new Ct(t.imprint)}toBigInt(){return this.value}toBytes(){return _t.encode(this.value).slice(1)}toString(){return this.value.toString(2).slice(1)}}class Pt{hash;constructor(t){this.hash=t}static create(t,e){return Pt.createFromImprint(t,e.imprint)}static async createFromImprint(t,e){const r=await new vt(O.SHA256).update(t).update(e).digest();return new Pt(r)}static fromCBOR(t){return new Pt(R.fromCBOR(t))}static fromJSON(t){return new Pt(R.fromJSON(t))}toBitString(){return Ct.fromDataHash(this.hash)}toJSON(){return this.hash.toJSON()}toCBOR(){return this.hash.toCBOR()}equals(t){return this.hash.equals(t.hash)}toString(){return`RequestId[${this.hash.toString()}]`}}class Ht{_bytes;recovery;algorithm="secp256k1";constructor(t,e){this._bytes=t,this.recovery=e,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static fromCBOR(t){return Ht.decode(N.readByteString(t))}static decode(t){if(65!==t.length)throw new Error("Signature must contain signature and recovery byte.");return new Ht(t.slice(0,-1),t[t.length-1])}static fromJSON(t){return Ht.decode(b.decode(t))}toJSON(){return b.encode(this.encode())}toCBOR(){return A.encodeByteString(this.encode())}encode(){return new Uint8Array([...this._bytes,this.recovery])}toString(){return`${b.encode(this.encode())}`}}class Ut extends w{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.createHasher");o(t.outputLen),o(t.blockLen)}(t);const r=p(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),h(i)}update(t){return c(this),this.iHash.update(t),this}digestInto(t){c(this),a(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:s,outputLen:o}=this;return t.finished=n,t.destroyed=i,t.blockLen=s,t.outputLen=o,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const kt=(t,e,r)=>new Ut(t,e).update(r).digest();kt.create=(t,e)=>new Ut(t,e);const Jt=BigInt(0),Dt=BigInt(1);function zt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function Kt(t){if(!zt(t))throw new Error("Uint8Array expected")}function $t(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}function qt(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function Mt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?Jt:BigInt("0x"+t)}const Lt="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,Ft=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function jt(t){if(Kt(t),Lt)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=Ft[t[r]];return e}function Gt(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-55:t>=97&&t<=102?t-87:void 0}function Vt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);if(Lt)return Uint8Array.fromHex(t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,i=0;e<r;e++,i+=2){const r=Gt(t.charCodeAt(i)),s=Gt(t.charCodeAt(i+1));if(void 0===r||void 0===s){const e=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+i)}n[e]=16*r+s}return n}function Yt(t){return Mt(jt(t))}function Zt(t){return Kt(t),Mt(jt(Uint8Array.from(t).reverse()))}function Wt(t,e){return Vt(t.toString(16).padStart(2*e,"0"))}function Xt(t,e){return Wt(t,e).reverse()}function Qt(t,e,r){let n;if("string"==typeof e)try{n=Vt(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!zt(e))throw new Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(t+" of length "+r+" expected, got "+i);return n}function te(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];Kt(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}const ee=t=>"bigint"==typeof t&&Jt<=t;function re(t,e,r){return ee(t)&&ee(e)&&ee(r)&&e<=t&&t<r}function ne(t,e,r,n){if(!re(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}const ie=t=>(Dt<<BigInt(t))-Dt,se=t=>new Uint8Array(t),oe=t=>Uint8Array.from(t),ae={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||zt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function ce(t,e,r={}){const n=(e,r,n)=>{const i=ae[r];if("function"!=typeof i)throw new Error("invalid validator function");const s=t[e];if(!(n&&void 0===s||i(s,t)))throw new Error("param "+String(e)+" is invalid. Expected "+r+", got "+s)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}function he(t){const e=new WeakMap;return(r,...n)=>{const i=e.get(r);if(void 0!==i)return i;const s=t(r,...n);return e.set(r,s),s}}const ue=BigInt(0),le=BigInt(1),de=BigInt(2),fe=BigInt(3),ge=BigInt(4),ye=BigInt(5),pe=BigInt(8);function we(t,e){const r=t%e;return r>=ue?r:e+r}function me(t,e,r){let n=t;for(;e-- >ue;)n*=n,n%=r;return n}function Se(t,e){if(t===ue)throw new Error("invert: expected non-zero number");if(e<=ue)throw new Error("invert: expected positive modulus, got "+e);let r=we(t,e),n=e,i=ue,s=le,o=le,a=ue;for(;r!==ue;){const t=n/r,e=n%r,c=i-o*t,h=s-a*t;n=r,r=e,i=o,s=a,o=c,a=h}if(n!==le)throw new Error("invert: does not exist");return we(i,e)}function be(t,e){const r=(t.ORDER+le)/ge,n=t.pow(e,r);if(!t.eql(t.sqr(n),e))throw new Error("Cannot find square root");return n}function Ae(t,e){const r=(t.ORDER-ye)/pe,n=t.mul(e,de),i=t.pow(n,r),s=t.mul(e,i),o=t.mul(t.mul(s,de),i),a=t.mul(s,t.sub(o,t.ONE));if(!t.eql(t.sqr(a),e))throw new Error("Cannot find square root");return a}const Oe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Be(t,e,r=!1){const n=new Array(e.length).fill(r?t.ZERO:void 0),i=e.reduce((e,r,i)=>t.is0(r)?e:(n[i]=e,t.mul(e,r)),t.ONE),s=t.inv(i);return e.reduceRight((e,r,i)=>t.is0(r)?e:(n[i]=t.mul(e,n[i]),t.mul(e,r)),s),n}function Ee(t,e){const r=(t.ORDER-le)/de,n=t.pow(e,r),i=t.eql(n,t.ONE),s=t.eql(n,t.ZERO),o=t.eql(n,t.neg(t.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function Ne(t,e){void 0!==e&&o(e);const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Re(t,e,r=!1,n={}){if(t<=ue)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:s}=Ne(t,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let o;const a=Object.freeze({ORDER:t,isLE:r,BITS:i,BYTES:s,MASK:ie(i),ZERO:ue,ONE:le,create:e=>we(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return ue<=e&&e<t},is0:t=>t===ue,isOdd:t=>(t&le)===le,neg:e=>we(-e,t),eql:(t,e)=>t===e,sqr:e=>we(e*e,t),add:(e,r)=>we(e+r,t),sub:(e,r)=>we(e-r,t),mul:(e,r)=>we(e*r,t),pow:(t,e)=>function(t,e,r){if(r<ue)throw new Error("invalid exponent, negatives unsupported");if(r===ue)return t.ONE;if(r===le)return e;let n=t.ONE,i=e;for(;r>ue;)r&le&&(n=t.mul(n,i)),i=t.sqr(i),r>>=le;return n}(a,t,e),div:(e,r)=>we(e*Se(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Se(e,t),sqrt:n.sqrt||(e=>{return o||(o=(r=t)%ge===fe?be:r%pe===ye?Ae:function(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-le,r=0;for(;e%de===ue;)e/=de,r++;let n=de;const i=Re(t);for(;1===Ee(i,n);)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(1===r)return be;let s=i.pow(n,e);const o=(e+le)/de;return function(t,n){if(t.is0(n))return n;if(1!==Ee(t,n))throw new Error("Cannot find square root");let i=r,a=t.mul(t.ONE,s),c=t.pow(n,e),h=t.pow(n,o);for(;!t.eql(c,t.ONE);){if(t.is0(c))return t.ZERO;let e=1,r=t.sqr(c);for(;!t.eql(r,t.ONE);)if(e++,r=t.sqr(r),e===i)throw new Error("Cannot find square root");const n=le<<BigInt(i-e-1),s=t.pow(a,n);i=e,a=t.sqr(s),c=t.mul(c,a),h=t.mul(h,s)}return h}}(r)),o(a,e);var r}),toBytes:t=>r?Xt(t,s):Wt(t,s),fromBytes:t=>{if(t.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+t.length);return r?Zt(t):Yt(t)},invertBatch:t=>Be(a,t),cmov:(t,e,r)=>r?e:t});return Object.freeze(a)}function Te(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Ie(t){const e=Te(t);return e+Math.ceil(e/2)}const ve=BigInt(0),xe=BigInt(1);function _e(t,e){const r=e.negate();return t?r:e}function Ce(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Pe(t,e){Ce(t,e);const r=2**t;return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1),mask:ie(t),maxNumber:r,shiftBy:BigInt(t)}}function He(t,e,r){const{windowSize:n,mask:i,maxNumber:s,shiftBy:o}=r;let a=Number(t&i),c=t>>o;a>n&&(a-=s,c+=xe);const h=e*n;return{nextN:c,offset:h+Math.abs(a)-1,isZero:0===a,isNeg:a<0,isNegF:e%2!=0,offsetF:h}}const Ue=new WeakMap,ke=new WeakMap;function Je(t){return ke.get(t)||1}function De(t,e,r,n){(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((t,r)=>{if(!(t instanceof e))throw new Error("invalid point at index "+r)})})(r,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((t,r)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+r)})}(n,e);const i=r.length,s=n.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,a=function(t){let e;for(e=0;t>Jt;t>>=Dt,e+=1);return e}(BigInt(i));let c=1;a>12?c=a-3:a>4?c=a-2:a>0&&(c=2);const h=ie(c),u=new Array(Number(h)+1).fill(o);let l=o;for(let t=Math.floor((e.BITS-1)/c)*c;t>=0;t-=c){u.fill(o);for(let e=0;e<s;e++){const i=n[e],s=Number(i>>BigInt(t)&h);u[s]=u[s].add(r[e])}let e=o;for(let t=u.length-1,r=o;t>0;t--)r=r.add(u[t]),e=e.add(r);if(l=l.add(e),0!==t)for(let t=0;t<c;t++)l=l.double()}return l}function ze(t){return ce(t.Fp,Oe.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),ce(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ne(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Ke(t){void 0!==t.lowS&&$t("lowS",t.lowS),void 0!==t.prehash&&$t("prehash",t.prehash)}class $e extends Error{constructor(t=""){super(t)}}const qe={Err:$e,_tlv:{encode:(t,e)=>{const{Err:r}=qe;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,i=qt(n);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const s=n>127?qt(i.length/2|128):"";return qt(t)+s+i+e},decode(t,e){const{Err:r}=qe;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const i=e[n++];let s=0;if(128&i){const t=127&i;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const o=e.subarray(n,n+t);if(o.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===o[0])throw new r("tlv.decode(long): zero leftmost byte");for(const t of o)s=s<<8|t;if(n+=t,s<128)throw new r("tlv.decode(long): not minimal encoding")}else s=i;const o=e.subarray(n,n+s);if(o.length!==s)throw new r("tlv.decode: wrong value length");return{v:o,l:e.subarray(n+s)}}},_int:{encode(t){const{Err:e}=qe;if(t<Le)throw new e("integer: negative integers are not allowed");let r=qt(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=qe;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return Yt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=qe,i=Qt("signature",t),{v:s,l:o}=n.decode(48,i);if(o.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,s),{v:h,l:u}=n.decode(2,c);if(u.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(h)}},hexFromSig(t){const{_tlv:e,_int:r}=qe,n=e.encode(2,r.encode(t.r))+e.encode(2,r.encode(t.s));return e.encode(48,n)}};function Me(t,e){return jt(Wt(t,e))}const Le=BigInt(0),Fe=BigInt(1),je=(BigInt(2),BigInt(3)),Ge=BigInt(4);function Ve(t){const e=function(t){const e=ze(t);return ce(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n,nByteLength:i,nBitLength:s}=e,o=r.BYTES+1,a=2*r.BYTES+1;function c(t){return we(t,n)}function h(t){return Se(t,n)}const{ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:f}=function(t){const e=function(t){const e=ze(t);ce(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:r,Fp:n,a:i}=e;if(r){if(!n.eql(i,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}(t),{Fp:r}=e,n=Re(e.n,e.nBitLength),i=e.toBytes||((t,e,n)=>{const i=e.toAffine();return te(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),s=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function o(t){const{a:n,b:i}=e,s=r.sqr(t),o=r.mul(s,t);return r.add(r.add(o,r.mul(t,n)),i)}function a(t,e){const n=r.sqr(e),i=o(t);return r.eql(n,i)}if(!a(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const c=r.mul(r.pow(e.a,je),Ge),h=r.mul(r.sqr(e.b),BigInt(27));if(r.is0(r.add(c,h)))throw new Error("bad curve params: a or b");function u(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:s}=e;if(r&&"bigint"!=typeof t){if(zt(t)&&(t=jt(t)),"string"!=typeof t||!r.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*n,"0")}let o;try{o="bigint"==typeof t?t:Yt(Qt("private key",t,n))}catch(e){throw new Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return i&&(o=we(o,s)),ne("private key",o,Fe,s),o}function l(t){if(!(t instanceof g))throw new Error("ProjectivePoint expected")}const d=he((t,e)=>{const{px:n,py:i,pz:s}=t;if(r.eql(s,r.ONE))return{x:n,y:i};const o=t.is0();null==e&&(e=o?r.ONE:r.inv(s));const a=r.mul(n,e),c=r.mul(i,e),h=r.mul(s,e);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(h,r.ONE))throw new Error("invZ was invalid");return{x:a,y:c}}),f=he(t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:n,y:i}=t.toAffine();if(!r.isValid(n)||!r.isValid(i))throw new Error("bad point: x or y not FE");if(!a(n,i))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class g{constructor(t,e,n){if(null==t||!r.isValid(t))throw new Error("x required");if(null==e||!r.isValid(e)||r.is0(e))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required");this.px=t,this.py=e,this.pz=n,Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw new Error("invalid affine point");if(t instanceof g)throw new Error("projective point not allowed");const i=t=>r.eql(t,r.ZERO);return i(e)&&i(n)?g.ZERO:new g(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=Be(r,t.map(t=>t.pz));return t.map((t,r)=>t.toAffine(e[r])).map(g.fromAffine)}static fromHex(t){const e=g.fromAffine(s(Qt("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return g.BASE.multiply(u(t))}static msm(t,e){return De(g,n,t,e)}_setWindowSize(t){w.setWindowSize(this,t)}assertValidity(){f(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){l(t);const{px:e,py:n,pz:i}=this,{px:s,py:o,pz:a}=t,c=r.eql(r.mul(e,a),r.mul(s,i)),h=r.eql(r.mul(n,a),r.mul(o,i));return c&&h}negate(){return new g(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,i=r.mul(n,je),{px:s,py:o,pz:a}=this;let c=r.ZERO,h=r.ZERO,u=r.ZERO,l=r.mul(s,s),d=r.mul(o,o),f=r.mul(a,a),y=r.mul(s,o);return y=r.add(y,y),u=r.mul(s,a),u=r.add(u,u),c=r.mul(t,u),h=r.mul(i,f),h=r.add(c,h),c=r.sub(d,h),h=r.add(d,h),h=r.mul(c,h),c=r.mul(y,c),u=r.mul(i,u),f=r.mul(t,f),y=r.sub(l,f),y=r.mul(t,y),y=r.add(y,u),u=r.add(l,l),l=r.add(u,l),l=r.add(l,f),l=r.mul(l,y),h=r.add(h,l),f=r.mul(o,a),f=r.add(f,f),l=r.mul(f,y),c=r.sub(c,l),u=r.mul(f,d),u=r.add(u,u),u=r.add(u,u),new g(c,h,u)}add(t){l(t);const{px:n,py:i,pz:s}=this,{px:o,py:a,pz:c}=t;let h=r.ZERO,u=r.ZERO,d=r.ZERO;const f=e.a,y=r.mul(e.b,je);let p=r.mul(n,o),w=r.mul(i,a),m=r.mul(s,c),S=r.add(n,i),b=r.add(o,a);S=r.mul(S,b),b=r.add(p,w),S=r.sub(S,b),b=r.add(n,s);let A=r.add(o,c);return b=r.mul(b,A),A=r.add(p,m),b=r.sub(b,A),A=r.add(i,s),h=r.add(a,c),A=r.mul(A,h),h=r.add(w,m),A=r.sub(A,h),d=r.mul(f,b),h=r.mul(y,m),d=r.add(h,d),h=r.sub(w,d),d=r.add(w,d),u=r.mul(h,d),w=r.add(p,p),w=r.add(w,p),m=r.mul(f,m),b=r.mul(y,b),w=r.add(w,m),m=r.sub(p,m),m=r.mul(f,m),b=r.add(b,m),p=r.mul(w,b),u=r.add(u,p),p=r.mul(A,b),h=r.mul(S,h),h=r.sub(h,p),p=r.mul(S,w),d=r.mul(A,d),d=r.add(d,p),new g(h,u,d)}subtract(t){return this.add(t.negate())}is0(){return this.equals(g.ZERO)}wNAF(t){return w.wNAFCached(this,t,g.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:i}=e;ne("scalar",t,Le,i);const s=g.ZERO;if(t===Le)return s;if(this.is0()||t===Fe)return this;if(!n||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,t,g.normalizeZ);let{k1neg:o,k1:a,k2neg:c,k2:h}=n.splitScalar(t),u=s,l=s,d=this;for(;a>Le||h>Le;)a&Fe&&(u=u.add(d)),h&Fe&&(l=l.add(d)),d=d.double(),a>>=Fe,h>>=Fe;return o&&(u=u.negate()),c&&(l=l.negate()),l=new g(r.mul(l.px,n.beta),l.py,l.pz),u.add(l)}multiply(t){const{endo:n,n:i}=e;let s,o;if(ne("scalar",t,Fe,i),n){const{k1neg:e,k1:i,k2neg:a,k2:c}=n.splitScalar(t);let{p:h,f:u}=this.wNAF(i),{p:l,f:d}=this.wNAF(c);h=w.constTimeNegate(e,h),l=w.constTimeNegate(a,l),l=new g(r.mul(l.px,n.beta),l.py,l.pz),s=h.add(l),o=u.add(d)}else{const{p:e,f:r}=this.wNAF(t);s=e,o=r}return g.normalizeZ([s,o])[0]}multiplyAndAddUnsafe(t,e,r){const n=g.BASE,i=(t,e)=>e!==Le&&e!==Fe&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),s=i(this,e).add(i(t,r));return s.is0()?void 0:s}toAffine(t){return d(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Fe)return!0;if(r)return r(g,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Fe?this:r?r(g,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return $t("isCompressed",t),this.assertValidity(),i(g,this,t)}toHex(t=!0){return $t("isCompressed",t),jt(this.toRawBytes(t))}}g.BASE=new g(e.Gx,e.Gy,r.ONE),g.ZERO=new g(r.ZERO,r.ONE,r.ZERO);const{endo:y,nBitLength:p}=e,w=(m=g,S=y?Math.ceil(p/2):p,{constTimeNegate:_e,hasPrecomputes:t=>1!==Je(t),unsafeLadder(t,e,r=m.ZERO){let n=t;for(;e>ve;)e&xe&&(r=r.add(n)),n=n.double(),e>>=xe;return r},precomputeWindow(t,e){const{windows:r,windowSize:n}=Pe(e,S),i=[];let s=t,o=s;for(let t=0;t<r;t++){o=s,i.push(o);for(let t=1;t<n;t++)o=o.add(s),i.push(o);s=o.double()}return i},wNAF(t,e,r){let n=m.ZERO,i=m.BASE;const s=Pe(t,S);for(let t=0;t<s.windows;t++){const{nextN:o,offset:a,isZero:c,isNeg:h,isNegF:u,offsetF:l}=He(r,t,s);r=o,c?i=i.add(_e(u,e[l])):n=n.add(_e(h,e[a]))}return{p:n,f:i}},wNAFUnsafe(t,e,r,n=m.ZERO){const i=Pe(t,S);for(let t=0;t<i.windows&&r!==ve;t++){const{nextN:s,offset:o,isZero:a,isNeg:c}=He(r,t,i);if(r=s,!a){const t=e[o];n=n.add(c?t.negate():t)}}return n},getPrecomputes(t,e,r){let n=Ue.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&Ue.set(e,r(n))),n},wNAFCached(t,e,r){const n=Je(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)},wNAFCachedUnsafe(t,e,r,n){const i=Je(t);return 1===i?this.unsafeLadder(t,e,n):this.wNAFUnsafe(i,this.getPrecomputes(i,t,r),e,n)},setWindowSize(t,e){Ce(e,S),ke.set(t,e),Ue.delete(t)}});var m,S;return{CURVE:e,ProjectivePoint:g,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:function(t){return re(t,Fe,e.n)}}}({...e,toBytes(t,e,n){const i=e.toAffine(),s=r.toBytes(i.x),o=te;return $t("isCompressed",n),n?o(Uint8Array.from([e.hasEvenY()?2:3]),s):o(Uint8Array.from([4]),s,r.toBytes(i.y))},fromBytes(t){const e=t.length,n=t[0],i=t.subarray(1);if(e!==o||2!==n&&3!==n){if(e===a&&4===n)return{x:r.fromBytes(i.subarray(0,r.BYTES)),y:r.fromBytes(i.subarray(r.BYTES,2*r.BYTES))};throw new Error("invalid Point, expected length of "+o+", or uncompressed "+a+", got "+e)}{const t=Yt(i);if(!re(t,Fe,r.ORDER))throw new Error("Point is not on curve");const e=d(t);let s;try{s=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~n)!=((s&Fe)===Fe)&&(s=r.neg(s)),{x:t,y:s}}}});function g(t){return t>n>>Fe}const y=(t,e,r)=>Yt(t.slice(e,r));class p{constructor(t,e,r){ne("r",t,Fe,n),ne("s",e,Fe,n),this.r=t,this.s=e,null!=r&&(this.recovery=r),Object.freeze(this)}static fromCompact(t){const e=i;return t=Qt("compactSignature",t,2*e),new p(y(t,0,e),y(t,e,2*e))}static fromDER(t){const{r:e,s:r}=qe.toSig(Qt("DER",t));return new p(e,r)}assertValidity(){}addRecoveryBit(t){return new p(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:i,recovery:s}=this,o=b(Qt("msgHash",t));if(null==s||![0,1,2,3].includes(s))throw new Error("recovery id invalid");const a=2===s||3===s?n+e.n:n;if(a>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const l=1&s?"03":"02",d=u.fromHex(l+Me(a,r.BYTES)),f=h(a),g=c(-o*f),y=c(i*f),p=u.BASE.multiplyAndAddUnsafe(d,g,y);if(!p)throw new Error("point at infinify");return p.assertValidity(),p}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return Vt(this.toDERHex())}toDERHex(){return qe.hexFromSig(this)}toCompactRawBytes(){return Vt(this.toCompactHex())}toCompactHex(){const t=i;return Me(this.r,t)+Me(this.s,t)}}const w={isValidPrivateKey(t){try{return l(t),!0}catch(t){return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const t=Ie(e.n);return function(t,e,r=!1){const n=t.length,i=Te(e),s=Ie(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const o=we(r?Zt(t):Yt(t),e-le)+le;return r?Xt(o,i):Wt(o,i)}(e.randomBytes(t),e.n)},precompute:(t=8,e=u.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function m(t){if("bigint"==typeof t)return!1;if(t instanceof u)return!0;const n=Qt("key",t).length,s=r.BYTES,o=s+1,a=2*s+1;return e.allowedPrivateKeyLengths||i===o?void 0:n===o||n===a}const S=e.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const e=Yt(t),r=8*t.length-s;return r>0?e>>BigInt(r):e},b=e.bits2int_modN||function(t){return c(S(t))},A=ie(s);function O(t){return ne("num < 2^"+s,t,Le,A),Wt(t,i)}const B={lowS:e.lowS,prehash:!1},E={lowS:e.lowS,prehash:!1};return u.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return u.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,r=!0){if(!0===m(t))throw new Error("first arg must be private key");if(!1===m(e))throw new Error("second arg must be public key");return u.fromHex(e).multiply(l(t)).toRawBytes(r)},sign:function(t,n,i=B){const{seed:s,k2sig:o}=function(t,n,i=B){if(["recovered","canonical"].some(t=>t in i))throw new Error("sign() legacy options not supported");const{hash:s,randomBytes:o}=e;let{lowS:a,prehash:d,extraEntropy:y}=i;null==a&&(a=!0),t=Qt("msgHash",t),Ke(i),d&&(t=Qt("prehashed msgHash",s(t)));const w=b(t),m=l(n),A=[O(m),O(w)];if(null!=y&&!1!==y){const t=!0===y?o(r.BYTES):y;A.push(Qt("extraEntropy",t))}const E=te(...A),N=w;return{seed:E,k2sig:function(t){const e=S(t);if(!f(e))return;const r=h(e),n=u.BASE.multiply(e).toAffine(),i=c(n.x);if(i===Le)return;const s=c(r*c(N+i*m));if(s===Le)return;let o=(n.x===i?0:2)|Number(n.y&Fe),l=s;return a&&g(s)&&(l=function(t){return g(t)?c(-t):t}(s),o^=1),new p(i,l,o)}}}(t,n,i),a=e;return function(t,e,r){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=se(t),i=se(t),s=0;const o=()=>{n.fill(1),i.fill(0),s=0},a=(...t)=>r(i,n,...t),c=(t=se(0))=>{i=a(oe([0]),t),n=a(),0!==t.length&&(i=a(oe([1]),t),n=a())},h=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return te(...r)};return(t,e)=>{let r;for(o(),c(t);!(r=e(h()));)c();return o(),r}}(a.hash.outputLen,a.nByteLength,a.hmac)(s,o)},verify:function(t,r,n,i=E){const s=t;r=Qt("msgHash",r),n=Qt("publicKey",n);const{lowS:o,prehash:a,format:l}=i;if(Ke(i),"strict"in i)throw new Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw new Error("format must be compact or der");const d="string"==typeof s||zt(s),f=!d&&!l&&"object"==typeof s&&null!==s&&"bigint"==typeof s.r&&"bigint"==typeof s.s;if(!d&&!f)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,y;try{if(f&&(g=new p(s.r,s.s)),d){try{"compact"!==l&&(g=p.fromDER(s))}catch(t){if(!(t instanceof qe.Err))throw t}g||"der"===l||(g=p.fromCompact(s))}y=u.fromHex(n)}catch(t){return!1}if(!g)return!1;if(o&&g.hasHighS())return!1;a&&(r=e.hash(r));const{r:w,s:m}=g,S=b(r),A=h(m),O=c(S*A),B=c(w*A),N=u.BASE.multiplyAndAddUnsafe(y,O,B)?.toAffine();return!!N&&c(N.x)===w},ProjectivePoint:u,Signature:p,utils:w}}function Ye(t){return{hash:t,hmac:(e,...r)=>kt(t,e,function(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];a(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}(...r)),randomBytes:S}}const Ze=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),We=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Xe=BigInt(0),Qe=BigInt(1),tr=BigInt(2),er=(t,e)=>(t+e/tr)/e;const rr=Re(Ze,void 0,void 0,{sqrt:function(t){const e=Ze,r=BigInt(3),n=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),a=BigInt(44),c=BigInt(88),h=t*t*t%e,u=h*h*t%e,l=me(u,r,e)*u%e,d=me(l,r,e)*u%e,f=me(d,tr,e)*h%e,g=me(f,i,e)*f%e,y=me(g,s,e)*g%e,p=me(y,a,e)*y%e,w=me(p,c,e)*p%e,m=me(w,a,e)*y%e,S=me(m,r,e)*u%e,b=me(S,o,e)*g%e,A=me(b,n,e)*h%e,O=me(A,tr,e);if(!rr.eql(rr.sqr(O),t))throw new Error("Cannot find square root");return O}}),nr=function(t,e){const r=e=>Ve({...t,...Ye(e)});return{...r(e),create:r}}({a:Xe,b:BigInt(7),Fp:rr,n:We,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=We,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Qe*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,o=BigInt("0x100000000000000000000000000000000"),a=er(s*t,e),c=er(-n*t,e);let h=we(t-a*r-c*i,e),u=we(-a*n-c*s,e);const l=h>o,d=u>o;if(l&&(h=e-h),d&&(u=e-u),h>o||u>o)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:h,k2neg:d,k2:u}}}},Ot);class ir{privateKey;_publicKey;constructor(t){this.privateKey=t,this.privateKey=new Uint8Array(t),this._publicKey=nr.getPublicKey(this.privateKey,!0)}get publicKey(){return new Uint8Array(this._publicKey)}get algorithm(){return"secp256k1"}static generatePrivateKey(){return nr.utils.randomPrivateKey()}static async createFromSecret(t,e){const r=new vt(O.SHA256);r.update(t),e&&r.update(e);const n=await r.digest();return new ir(n.data)}static verifySignatureWithRecoveredPublicKey(t,e){const r=nr.Signature.fromCompact(e.bytes).addRecoveryBit(e.recovery).recoverPublicKey(t.data).toRawBytes();return ir.verifyWithPublicKey(t,e.bytes,r)}static verifyWithPublicKey(t,e,r){return Promise.resolve(nr.verify(e,t.data,r,{format:"compact"}))}verify(t,e){return ir.verifyWithPublicKey(t,e.bytes,this._publicKey)}sign(t){const e=nr.sign(t.data,this.privateKey);return Promise.resolve(new Ht(e.toCompactRawBytes(),e.recovery))}}function sr(t,...e){if(0===t.length)return"";let r=t[0].split("\n");if(0!==r.shift()?.length)throw new Error("First line must be empty");const n=r[0].length-r[0].trimStart().length,i=[];for(let s=0;s<t.length;s++){i.push(`${i.pop()||""}${r[0].slice(Math.min(r[0].length-r[0].trim().length,n))}`);for(let t=1;t<r.length;t++)i.push(r[t].slice(n));const o=i.pop(),a=o.length-o.trimStart().length,c=s<e.length?String(e[s]).split("\n"):[""];i.push(`${o}${c[0]}`);for(let t=1;t<c.length;t++)i.push(`${" ".repeat(a)}${c[t]}`);r=s+1<t.length?t[s+1].split("\n"):[]}return i.join("\n")}class or{algorithm;_publicKey;signature;stateHash;constructor(t,e,r,n){this.algorithm=t,this._publicKey=e,this.signature=r,this.stateHash=n,this._publicKey=new Uint8Array(e)}get publicKey(){return new Uint8Array(this._publicKey)}static async create(t,e,r){return new or(t.algorithm,t.publicKey,await t.sign(e),r)}static fromJSON(t){if(!or.isJSON(t))throw new Error("Parsing authenticator dto failed.");return new or(t.algorithm,b.decode(t.publicKey),Ht.fromJSON(t.signature),R.fromJSON(t.stateHash))}static isJSON(t){return"object"==typeof t&&null!==t&&"publicKey"in t&&"string"==typeof t.publicKey&&"algorithm"in t&&"string"==typeof t.algorithm&&"signature"in t&&"string"==typeof t.signature&&"stateHash"in t&&"string"==typeof t.stateHash}static fromCBOR(t){const e=N.readArray(t);return new or(N.readTextString(e[0]),N.readByteString(e[1]),Ht.decode(N.readByteString(e[2])),R.fromImprint(N.readByteString(e[3])))}toCBOR(){return A.encodeArray([A.encodeTextString(this.algorithm),A.encodeByteString(this.publicKey),A.encodeByteString(this.signature.encode()),A.encodeByteString(this.stateHash.imprint)])}toJSON(){return{algorithm:this.algorithm,publicKey:b.encode(this.publicKey),signature:this.signature.toJSON(),stateHash:this.stateHash.toJSON()}}verify(t){return ir.verifyWithPublicKey(t,this.signature.bytes,this.publicKey)}calculateRequestId(){return Pt.create(this._publicKey,this.stateHash)}toString(){return sr`
      Authenticator
        Public Key: ${b.encode(this._publicKey)}
        Signature Algorithm: ${this.algorithm}
        Signature: ${this.signature.toString()}
        State Hash: ${this.stateHash.toString()}`}}class ar{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static async create(t,e){const r=await new vt(O.SHA256).update(t.toCBOR()).update(e.imprint).digest();return new ar(r.imprint)}equals(t){return!!ArrayBuffer.isView(t)&&b.encode(this.bytes)===b.encode(new Uint8Array(t.buffer,t.byteOffset,t.byteLength))}toString(){return`LeafValue[${b.encode(this.bytes)}]`}}class cr{path;_value;hash;constructor(t,e,r){this.path=t,this._value=e,this.hash=r}get value(){return new Uint8Array(this._value)}finalize(){return Promise.resolve(this)}toString(){return`\n      Leaf[${this.path.toString(2)}]\n        Value: ${b.encode(this._value)}\n    `}}class hr{_value;constructor(t){this._value=t,this._value=t?new Uint8Array(t):null}get value(){return this._value?new Uint8Array(this._value):null}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Parsing merkle tree path step branch failed.");const e=t.at(0);return new hr(e?b.decode(e):null)}static fromCBOR(t){const e=N.readArray(t);return new hr(N.readOptional(e[0],N.readByteString))}toCBOR(){return A.encodeArray([A.encodeOptional(this._value,A.encodeByteString)])}toJSON(){return this._value?[b.encode(this._value)]:[]}toString(){return`MerkleTreePathStepBranch[${this._value?b.encode(this._value):"null"}]`}}class ur{path;sibling;branch;constructor(t,e,r){this.path=t,this.sibling=e,this.branch=r}static createWithoutBranch(t,e){return new ur(t,e?.hash??null,null)}static create(t,e,r){return new ur(t,r?.hash??null,new hr(null==e?null:e instanceof cr?e.value:e.childrenHash.data))}static isJSON(t){return"object"==typeof t&&null!==t&&"path"in t&&"string"==typeof t.path&&"sibling"in t&&"branch"in t}static fromJSON(t){if(!ur.isJSON(t))throw new Error("Parsing merkle tree path step failed.");return new ur(BigInt(t.path),null==t.sibling?null:R.fromJSON(t.sibling),null!=t.branch?hr.fromJSON(t.branch):null)}static fromCBOR(t){const e=N.readArray(t);return new ur(_t.decode(N.readByteString(e[0])),N.readOptional(e[1],R.fromCBOR),N.readOptional(e[2],hr.fromCBOR))}toCBOR(){return A.encodeArray([A.encodeByteString(_t.encode(this.path)),this.sibling?.toCBOR()??A.encodeNull(),this.branch?.toCBOR()??A.encodeNull()])}toJSON(){return{branch:this.branch?.toJSON()??null,path:this.path.toString(),sibling:this.sibling?.toJSON()??null}}toString(){return sr`
      Merkle Tree Path Step
        Path: ${this.path.toString(2)}
        Branch: ${this.branch?.toString()??"null"}
        Sibling: ${this.sibling?.toString()??"null"}`}}class lr{isPathValid;isPathIncluded;result;constructor(t,e){this.isPathValid=t,this.isPathIncluded=e,this.result=t&&e}}class dr{root;steps;constructor(t,e){this.root=t,this.steps=e}static fromJSON(t){if(!dr.isJSON(t))throw new Error("Parsing merkle tree path json failed.");return new dr(R.fromJSON(t.root),t.steps.map(t=>ur.fromJSON(t)))}static isJSON(t){return"object"==typeof t&&null!==t&&"root"in t&&"string"==typeof t.root&&"steps"in t&&Array.isArray(t.steps)}static fromCBOR(t){const e=N.readArray(t),r=N.readArray(e[1]);return new dr(R.fromCBOR(e[0]),r.map(t=>ur.fromCBOR(t)))}toCBOR(){return A.encodeArray([this.root.toCBOR(),A.encodeArray(this.steps.map(t=>t.toCBOR()))])}toJSON(){return{root:this.root.toJSON(),steps:this.steps.map(t=>t.toJSON())}}async verify(t){let e=1n,r=null;for(let t=0;t<this.steps.length;t++){const n=this.steps[t];let i;if(null===n.branch)i=new Uint8Array(1);else{const s=0===t?n.branch.value:r?.data;i=(await new vt(O.SHA256).update(_t.encode(n.path)).update(s??new Uint8Array(1)).digest()).data;const o=BigInt(n.path.toString(2).length-1);e=e<<o|n.path&(1n<<o)-1n}const s=n.sibling?.data??new Uint8Array(1),o=1n&n.path;r=await new vt(O.SHA256).update(o?s:i).update(o?i:s).digest()}return new lr(!!r&&this.root.equals(r),t===e)}toString(){return sr`
      Merkle Tree Path
        Root: ${this.root.toString()} 
        Steps: [
          ${this.steps.map(t=>t?.toString()??"null").join("\n")}
        ]`}}var fr,gr;!function(t){t.NOT_AUTHENTICATED="NOT_AUTHENTICATED",t.PATH_NOT_INCLUDED="PATH_NOT_INCLUDED",t.PATH_INVALID="PATH_INVALID",t.OK="OK"}(fr||(fr={}));class yr{merkleTreePath;authenticator;transactionHash;constructor(t,e,r){if(this.merkleTreePath=t,this.authenticator=e,this.transactionHash=r,!this.authenticator!=!this.transactionHash)throw new Error("Authenticator and transaction hash must be both set or both null.")}static isJSON(t){return"object"==typeof t&&null!==t&&"merkleTreePath"in t}static fromJSON(t){if(!yr.isJSON(t))throw new Error("Parsing inclusion proof json failed.");return new yr(dr.fromJSON(t.merkleTreePath),t.authenticator?or.fromJSON(t.authenticator):null,t.transactionHash?R.fromJSON(t.transactionHash):null)}static fromCBOR(t){const e=N.readArray(t),r=N.readOptional(e[1],or.fromCBOR),n=N.readOptional(e[2],R.fromCBOR);return new yr(dr.fromCBOR(e[0]),r,n)}toJSON(){return{authenticator:this.authenticator?.toJSON()??null,merkleTreePath:this.merkleTreePath.toJSON(),transactionHash:this.transactionHash?.toJSON()??null}}toCBOR(){return A.encodeArray([this.merkleTreePath.toCBOR(),this.authenticator?.toCBOR()??A.encodeNull(),this.transactionHash?.toCBOR()??A.encodeNull()])}async verify(t){if(this.authenticator&&this.transactionHash){if(!await this.authenticator.verify(this.transactionHash))return fr.NOT_AUTHENTICATED;if(!(await ar.create(this.authenticator,this.transactionHash)).equals(this.merkleTreePath.steps.at(0)?.branch?.value))return fr.PATH_NOT_INCLUDED}const e=await this.merkleTreePath.verify(t.toBitString().toBigInt());return e.isPathValid?e.isPathIncluded?fr.OK:fr.PATH_NOT_INCLUDED:fr.PATH_INVALID}toString(){return sr`
      Inclusion Proof
        ${this.merkleTreePath.toString()}
        ${this.authenticator?.toString()}
        Transaction Hash: ${this.transactionHash?.toString()??null}`}}class pr{requestId;transactionHash;authenticator;receipt;constructor(t,e,r,n){this.requestId=t,this.transactionHash=e,this.authenticator=r,this.receipt=n}static fromJSON(t){if(!pr.isJSON(t))throw new Error("Parsing submit state transition request failed.");return new pr(Pt.fromJSON(t.requestId),R.fromJSON(t.transactionHash),or.fromJSON(t.authenticator),t.receipt)}static isJSON(t){return"object"==typeof t&&null!==t&&"authenticator"in t&&"object"==typeof t.authenticator&&null!==t.authenticator&&"requestId"in t&&"string"==typeof t.requestId&&"transactionHash"in t&&"string"==typeof t.transactionHash}toJSON(){return{authenticator:this.authenticator.toJSON(),receipt:this.receipt,requestId:this.requestId.toJSON(),transactionHash:this.transactionHash.toJSON()}}}!function(t){t.SUCCESS="SUCCESS",t.AUTHENTICATOR_VERIFICATION_FAILED="AUTHENTICATOR_VERIFICATION_FAILED",t.REQUEST_ID_MISMATCH="REQUEST_ID_MISMATCH",t.REQUEST_ID_EXISTS="REQUEST_ID_EXISTS"}(gr||(gr={}));class wr{service;method;requestId;stateHash;transactionHash;hash;constructor(t,e,r,n,i,s){this.service=t,this.method=e,this.requestId=r,this.stateHash=n,this.transactionHash=i,this.hash=s}static async create(t,e,r,n,i){const s=A.encodeArray([A.encodeTextString(t),A.encodeTextString(e),r.toCBOR(),n.toCBOR(),i.toCBOR()]),o=await new vt(O.SHA256).update(s).digest();return new wr(t,e,r,n,i,o)}toCBOR(){return A.encodeArray([A.encodeTextString(this.service),A.encodeTextString(this.method),this.requestId.toCBOR(),this.stateHash.toCBOR(),this.transactionHash.toCBOR()])}toJSON(){return{method:this.method,requestId:this.requestId.toJSON(),service:this.service,stateHash:this.stateHash.toJSON(),transactionHash:this.transactionHash.toJSON()}}toString(){return sr`
      Request
        Service: ${this.service}
        Method: ${this.method}
        Request ID: ${this.requestId.toString()}
        State Hash: ${this.stateHash.toString()}
        Transaction Hash: ${this.transactionHash.toString()}
      `}}class mr{status;receipt;constructor(t,e){this.status=t,this.receipt=e}static async fromJSON(t){if(!mr.isJSON(t))throw new Error("Parsing submit state transition response failed.");let e;if(t.request&&t.algorithm&&t.publicKey&&t.signature){const r=await wr.create(t.request.service,t.request.method,Pt.fromJSON(t.request.requestId),R.fromJSON(t.request.stateHash),R.fromJSON(t.request.transactionHash));e={algorithm:t.algorithm,publicKey:t.publicKey,request:r,signature:Ht.fromJSON(t.signature)}}return new mr(t.status,e)}static isJSON(t){return"object"==typeof t&&null!==t&&"status"in t&&"string"==typeof t.status}toJSON(){return{algorithm:this.receipt?.algorithm,publicKey:this.receipt?.publicKey,request:this.receipt?.request.toJSON(),signature:this.receipt?.signature.toJSON(),status:this.status}}async addSignedReceipt(t,e,r,n){const i=await wr.create("aggregator","submit_commitment",t,e,r),s=await n.sign(i.hash);this.receipt={algorithm:n.algorithm,publicKey:b.encode(n.publicKey),request:i,signature:s}}verifyReceipt(){return this.receipt?ir.verifyWithPublicKey(this.receipt.request.hash,this.receipt.signature.bytes,b.decode(this.receipt.publicKey)):Promise.resolve(!1)}}const Sr={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let br;const Ar=new Uint8Array(16),Or=[];for(let t=0;t<256;++t)Or.push((t+256).toString(16).slice(1));const Br=function(t,e,r){if(Sr.randomUUID&&!e&&!t)return Sr.randomUUID();const n=(t=t||{}).random??t.rng?.()??function(){if(!br){if("undefined"==typeof crypto||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");br=crypto.getRandomValues.bind(crypto)}return br(Ar)}();if(n.length<16)throw new Error("Random bytes length must be >= 16");if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,e){if((r=r||0)<0||r+16>e.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let t=0;t<16;++t)e[r+t]=n[t];return e}return function(t,e=0){return(Or[t[e+0]]+Or[t[e+1]]+Or[t[e+2]]+Or[t[e+3]]+"-"+Or[t[e+4]]+Or[t[e+5]]+"-"+Or[t[e+6]]+Or[t[e+7]]+"-"+Or[t[e+8]]+Or[t[e+9]]+"-"+Or[t[e+10]]+Or[t[e+11]]+Or[t[e+12]]+Or[t[e+13]]+Or[t[e+14]]+Or[t[e+15]]).toLowerCase()}(n)};class Er{code;message;name="JsonRpcError";constructor({code:t,message:e}){this.code=t,this.message=e}toString(){return`{ code: ${this.code}, message: ${this.message} }`}}class Nr{status;message;name="JsonRpcNetworkError";constructor(t,e){this.status=t,this.message=e}}class Rr{url;constructor(t){this.url=t}async request(t,e){const r=await fetch(this.url,{body:JSON.stringify({id:Br(),jsonrpc:"2.0",method:t,params:e}),headers:{"Content-Type":"application/json"},method:"POST"});if(!r.ok)throw new Nr(r.status,await r.text());const n=await r.json();if(n.error)throw new Er(n.error);return n.result}}class Tr{transport;constructor(t){this.transport=new Rr(t)}async submitTransaction(t,e,r,n=!1){const i=new pr(t,e,r,n),s=await this.transport.request("submit_commitment",i.toJSON());return mr.fromJSON(s)}async getInclusionProof(t,e){const r={blockNum:e?.toString(),requestId:t.toJSON()};return yr.fromJSON(await this.transport.request("get_inclusion_proof",r))}getNoDeletionProof(t){const e={requestId:t.toJSON()};return this.transport.request("get_no_deletion_proof",e)}async getBlockHeight(){const t=await this.transport.request("get_block_height",{});if(t&&"object"==typeof t&&"blockNumber"in t&&("string"==typeof t.blockNumber||"number"==typeof t.blockNumber||"bigint"==typeof t.blockNumber))return BigInt(t.blockNumber);throw new Error("Invalid response format for block height")}}var Ir;!function(t){t.MASKED="MASKED",t.UNMASKED="UNMASKED",t.BURN="BURN"}(Ir||(Ir={}));const vr=Ir.BURN;class xr{reference;hash;_nonce;reason;type=vr;constructor(t,e,r,n){this.reference=t,this.hash=e,this._nonce=r,this.reason=n}get nonce(){return new Uint8Array(this._nonce)}static async create(t,e,r,n){const i=await xr.calculateReference(e,n),s=await xr.calculateHash(i,t,r);return new xr(i,s,r,n)}static fromJSON(t,e,r){if(!xr.isJSON(r))throw new Error("Invalid burn predicate json");return xr.create(t,e,b.decode(r.nonce),R.fromJSON(r.reason))}static fromCBOR(t,e,r){const n=N.readArray(r),i=N.readTextString(n[0]);if(i!==Ir.BURN)throw new Error(`Invalid predicate type: expected ${Ir.BURN}, got ${i}`);return xr.create(t,e,N.readByteString(n[1]),R.fromCBOR(n[2]))}static calculateReference(t,e){return new vt(O.SHA256).update(A.encodeArray([A.encodeTextString(vr),t.toCBOR(),e.toCBOR()])).digest()}static isJSON(t){return"object"==typeof t&&null!==t&&"type"in t&&t.type===Ir.BURN&&"nonce"in t&&"string"==typeof t.nonce&&"reason"in t&&"string"==typeof t.reason}static calculateHash(t,e,r){return new vt(O.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR(),A.encodeByteString(r)])).digest()}toJSON(){return{nonce:b.encode(this._nonce),reason:this.reason.toJSON(),type:this.type}}toCBOR(){return A.encodeArray([A.encodeTextString(this.type),A.encodeByteString(this._nonce),this.reason.toCBOR()])}verify(){return Promise.resolve(!1)}toString(){return sr`
          Predicate[${this.type}]:
            Hash: ${this.hash.toString()}`}isOwner(){return Promise.resolve(!1)}}class _r{type;_publicKey;algorithm;hashAlgorithm;_nonce;reference;hash;constructor(t,e,r,n,i,s,o){this.type=t,this._publicKey=e,this.algorithm=r,this.hashAlgorithm=n,this._nonce=i,this.reference=s,this.hash=o,this._publicKey=new Uint8Array(e),this._nonce=new Uint8Array(i)}get publicKey(){return this._publicKey}get nonce(){return this._nonce}static isJSON(t){return"object"==typeof t&&null!==t&&"publicKey"in t&&"string"==typeof t.publicKey&&"algorithm"in t&&"string"==typeof t.algorithm&&"hashAlgorithm"in t&&!!O[t.hashAlgorithm]&&"nonce"in t&&"string"==typeof t.nonce}toJSON(){return{algorithm:this.algorithm,hashAlgorithm:this.hashAlgorithm,nonce:b.encode(this.nonce),publicKey:b.encode(this.publicKey),type:this.type}}toCBOR(){return A.encodeArray([A.encodeTextString(this.type),A.encodeByteString(this.publicKey),A.encodeTextString(this.algorithm),A.encodeUnsignedInteger(this.hashAlgorithm),A.encodeByteString(this.nonce)])}async verify(t){if(!t.inclusionProof.authenticator||!t.inclusionProof.transactionHash)return!1;if(b.encode(t.inclusionProof.authenticator.publicKey)!==b.encode(this.publicKey)||!t.inclusionProof.authenticator.stateHash.equals(t.data.sourceState.hash))return!1;if(!await t.inclusionProof.authenticator.verify(t.data.hash))return!1;const e=await Pt.create(this.publicKey,t.data.sourceState.hash);return await t.inclusionProof.verify(e)===fr.OK}toString(){return sr`
          Predicate[${this.type}]:
            PublicKey: ${b.encode(this.publicKey)}
            Algorithm: ${this.algorithm}
            Hash Algorithm: ${O[this.hashAlgorithm]}
            Nonce: ${b.encode(this.nonce)}
            Hash: ${this.hash.toString()}`}isOwner(t){return Promise.resolve(b.encode(t)===b.encode(this.publicKey))}}const Cr=Ir.MASKED;class Pr extends _r{constructor(t,e,r,n,i,s){super(Cr,t,e,r,n,i,s)}static create(t,e,r,n,i){return Pr.createFromPublicKey(t,e,r.algorithm,r.publicKey,n,i)}static async createFromPublicKey(t,e,r,n,i,s){const o=await Pr.calculateReference(e,r,n,i,s),a=await Pr.calculateHash(o,t);return new Pr(n,r,i,s,o,a)}static fromJSON(t,e,r){if(!_r.isJSON(r)||r.type!==Cr)throw new Error("Invalid masked predicate json.");return Pr.createFromPublicKey(t,e,r.algorithm,b.decode(r.publicKey),r.hashAlgorithm,b.decode(r.nonce))}static fromCBOR(t,e,r){const n=N.readArray(r),i=N.readTextString(n[0]);if(i!==Ir.MASKED)throw new Error(`Invalid predicate type: expected ${Ir.MASKED}, got ${i}`);const s=Number(N.readUnsignedInteger(n[3]));if(null==O[s])throw new Error(`Invalid hash algorithm: ${s}`);return Pr.createFromPublicKey(t,e,N.readTextString(n[2]),N.readByteString(n[1]),s,N.readByteString(n[4]))}static calculateReference(t,e,r,n,i){return new vt(O.SHA256).update(A.encodeArray([A.encodeTextString(Cr),t.toCBOR(),A.encodeTextString(e),A.encodeTextString(O[n]),A.encodeByteString(r),A.encodeByteString(i)])).digest()}static calculateHash(t,e){return new vt(O.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR()])).digest()}}const Hr=Ir.UNMASKED;class Ur extends _r{constructor(t,e,r,n,i,s){super(Hr,t,e,r,n,i,s)}static async create(t,e,r,n,i){const s=await new vt(O.SHA256).update(i).digest(),o=await r.sign(s);return Ur.createFromPublicKey(t,e,r.algorithm,r.publicKey,n,o.bytes)}static async createFromPublicKey(t,e,r,n,i,s){const o=await Ur.calculateReference(e,r,n,i),a=await Ur.calculateHash(o,t,s);return new Ur(n,r,i,s,o,a)}static fromJSON(t,e,r){if(!_r.isJSON(r)||r.type!==Hr)throw new Error("Invalid unmasked predicate json.");return Ur.createFromPublicKey(t,e,r.algorithm,b.decode(r.publicKey),r.hashAlgorithm,b.decode(r.nonce))}static fromCBOR(t,e,r){const n=N.readArray(r),i=N.readTextString(n[0]);if(i!==Ir.UNMASKED)throw new Error(`Invalid predicate type: expected ${Ir.UNMASKED}, got ${i}`);const s=Number(N.readUnsignedInteger(n[3]));if(null==O[s])throw new Error(`Invalid hash algorithm: ${s}`);return Ur.createFromPublicKey(t,e,N.readTextString(n[2]),N.readByteString(n[1]),s,N.readByteString(n[4]))}static calculateReference(t,e,r,n){return new vt(O.SHA256).update(A.encodeArray([A.encodeTextString(Hr),t.toCBOR(),A.encodeTextString(e),A.encodeTextString(O[n]),A.encodeByteString(r)])).digest()}static calculateHash(t,e,r){return new vt(O.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR(),A.encodeByteString(r)])).digest()}}class kr{create(t,e,r){switch(r.type){case Ir.BURN:return xr.fromJSON(t,e,r);case Ir.MASKED:return Pr.fromJSON(t,e,r);case Ir.UNMASKED:return Ur.fromJSON(t,e,r);default:throw new Error(`Unknown predicate type: ${r.type}`)}}}class Jr{static decode(){return Promise.resolve(new Jr)}toJSON(){throw new Error("toJSON method is not implemented.")}toCBOR(){throw new Error("toCBOR method is not implemented.")}}class Dr{unlockPredicate;_data;hash;constructor(t,e,r){this.unlockPredicate=t,this._data=e,this.hash=r,this._data=e?new Uint8Array(e):null}get data(){return this._data?new Uint8Array(this._data):null}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e){return new Dr(t,e,await new vt(O.SHA256).update(A.encodeArray([t.hash.toCBOR(),A.encodeOptional(e,A.encodeByteString)])).digest())}toString(){return sr`
        TokenState:
          ${this.unlockPredicate.toString()}
          Data: ${this._data?b.encode(this._data):null}
          Hash: ${this.hash.toString()}`}}class zr{predicateFactory;constructor(t){this.predicateFactory=t}static serialize(t){return A.encodeArray([t.unlockPredicate.toCBOR(),A.encodeOptional(t.data,A.encodeByteString)])}async deserialize(t,e,r){const n=N.readArray(r);return Dr.create(await this.predicateFactory.create(t,e,n[0]),N.readOptional(n[1],N.readByteString))}}class Kr{path;_value;sum;hash;constructor(t,e,r,n){this.path=t,this._value=e,this.sum=r,this.hash=n}get value(){return new Uint8Array(this._value)}finalize(){return Promise.resolve(this)}toString(){return sr`
      Leaf[${this.path.toString(2)}]
        Hash: ${this.hash.toString()}
        Value: ${b.encode(this._value)}
        Sum: ${this.sum}`}}class $r{sum;hash;constructor(t,e){this.sum=t,this.hash=e}static create(t){return new $r(t.sum,t.hash)}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t)||2!==t.length)throw new Error("Parsing merkle tree path step branch failed.");return new $r(BigInt(t[0]),R.fromJSON(t[1]))}static fromCBOR(t){const e=N.readArray(t);return new $r(_t.decode(N.readByteString(e[0])),R.fromCBOR(e[1]))}toCBOR(){return A.encodeArray([A.encodeByteString(_t.encode(this.sum)),this.hash.toCBOR()])}toJSON(){return[this.sum.toString(),this.hash.toJSON()]}toString(){return`MerkleSumTreePathStepSibling[${this.sum},${this.hash.toString()}]`}}class qr{sum;_value;constructor(t,e){this.sum=t,this._value=e,this._value=e?new Uint8Array(e):null}get value(){return this._value?new Uint8Array(this._value):null}static isJSON(t){return Array.isArray(t)}static fromJSON(t){if(!Array.isArray(t))throw new Error("Parsing merkle tree path step branch failed.");const e=t.at(0),r=t.at(1);return new qr(BigInt(e??0n),r?b.decode(r):null)}static fromCBOR(t){const e=N.readArray(t);return new qr(_t.decode(N.readByteString(e[0])),N.readOptional(e[1],N.readByteString))}toCBOR(){return A.encodeArray([A.encodeOptional(this._value,A.encodeByteString)])}toJSON(){return[this.sum.toString(),this._value?b.encode(this._value):null]}toString(){return`MerkleSumTreePathStepBranch[${this._value?b.encode(this._value):"null"}]`}}class Mr{path;sibling;branch;constructor(t,e,r){this.path=t,this.sibling=e,this.branch=r}static createWithoutBranch(t,e){return new Mr(t,e?$r.create(e):null,null)}static create(t,e,r){return new Mr(t,r?$r.create(r):null,null==e?new qr(0n,null):new qr(e.sum,e instanceof Kr?e.value:e.childrenHash.data))}static isJSON(t){return"object"==typeof t&&null!==t&&"path"in t&&"string"==typeof t.path&&"sibling"in t&&"branch"in t}static fromJSON(t){if(!Mr.isJSON(t))throw new Error("Parsing merkle tree path step failed.");return new Mr(BigInt(t.path),null!=t.sibling?$r.fromJSON(t.sibling):null,null!=t.branch?qr.fromJSON(t.branch):null)}static fromCBOR(t){const e=N.readArray(t);return new Mr(_t.decode(N.readByteString(e[0])),N.readOptional(e[1],$r.fromCBOR),N.readOptional(e[2],qr.fromCBOR))}toCBOR(){return A.encodeArray([A.encodeByteString(_t.encode(this.path)),this.sibling?.toCBOR()??A.encodeNull(),this.branch?.toCBOR()??A.encodeNull()])}toJSON(){return{branch:this.branch?.toJSON()??null,path:this.path.toString(),sibling:this.sibling?.toJSON()??null}}toString(){return sr`
      Merkle Tree Path Step
        Path: ${this.path.toString(2)}
        Branch: ${this.branch?.toString()??"null"}
        Sibling: ${this.sibling?.toString()??"null"}`}}class Lr{root;sum;steps;constructor(t,e,r){this.root=t,this.sum=e,this.steps=r}static fromJSON(t){if(!Lr.isJSON(t))throw new Error("Parsing merkle tree path json failed.");return new Lr(R.fromJSON(t.root),BigInt(t.sum),t.steps.map(t=>Mr.fromJSON(t)))}static isJSON(t){return"object"==typeof t&&null!==t&&"root"in t&&"string"==typeof t.root&&"steps"in t&&Array.isArray(t.steps)}static fromCBOR(t){const e=N.readArray(t);return new Lr(R.fromCBOR(e[0]),_t.decode(N.readByteString(e[1])),N.readArray(e[2]).map(t=>Mr.fromCBOR(t)))}toCBOR(){return A.encodeArray([this.root.toCBOR(),A.encodeArray(this.steps.map(t=>t.toCBOR()))])}toJSON(){return{root:this.root.toJSON(),steps:this.steps.map(t=>t.toJSON()),sum:this.sum.toString()}}async verify(t){let e=1n,r=null,n=this.steps.at(0)?.branch?.sum??0n;for(let t=0;t<this.steps.length;t++){const i=this.steps[t];let s=null;if(null!==i.branch){const o=0===t?i.branch.value:r?r.imprint:null;s=await new vt(O.SHA256).update(A.encodeArray([A.encodeByteString(_t.encode(i.path)),o?A.encodeByteString(o):A.encodeNull(),A.encodeByteString(_t.encode(n))])).digest();const a=BigInt(i.path.toString(2).length-1);e=e<<a|i.path&(1n<<a)-1n}const o=1n&i.path,a=o?s?[s,n]:null:i.sibling?[i.sibling.hash,i.sibling.sum]:null,c=o?i.sibling?[i.sibling.hash,i.sibling.sum]:null:s?[s,n]:null;r=await new vt(O.SHA256).update(A.encodeArray([c?A.encodeArray([A.encodeByteString(c[0].imprint),A.encodeByteString(_t.encode(c[1]))]):A.encodeNull(),a?A.encodeArray([a[0]?A.encodeByteString(a[0].imprint):A.encodeNull(),A.encodeByteString(_t.encode(a[1]))]):A.encodeNull()])).digest(),n+=i.sibling?.sum??0n}return new lr(!!r&&this.root.equals(r)&&n===this.sum,t===e)}toString(){return sr`
      Merkle Tree Path
        Root: ${this.root.toString()} 
        Steps: [
          ${this.steps.map(t=>t?.toString()??"null").join("\n")}
        ]`}}var Fr;!function(t){t.TOKEN_SPLIT="TOKEN_SPLIT"}(Fr||(Fr={}));class jr{token;_proofs;constructor(t,e){this.token=t,this._proofs=e,this._proofs=new Map(e)}get proofs(){return new Map(this._proofs)}toCBOR(){return A.encodeArray([this.token.toCBOR(),A.encodeArray(Array.from(this._proofs.entries()).map(([t,e])=>A.encodeArray([A.encodeByteString(_t.encode(t)),e.toCBOR()])))])}toJSON(){return{proofs:Array.from(this._proofs).map(([t,e])=>[t.toString(),e.toJSON()]),token:this.token.toJSON(),type:Fr.TOKEN_SPLIT}}}class Gr{aggregationPath;coinTreePath;constructor(t,e){this.aggregationPath=t,this.coinTreePath=e}toJSON(){return{aggregationPath:this.aggregationPath.toJSON(),coinTreePath:this.coinTreePath.toJSON()}}toCBOR(){return A.encodeArray([this.aggregationPath.toCBOR(),this.coinTreePath.toCBOR()])}}class Vr{data;constructor(t){this.data=t,this.data=new Uint8Array(t)}static fromJSON(t){return new Vr(b.decode(t))}static fromCBOR(t){return new Vr(N.readByteString(t))}toJSON(){return b.encode(this.data)}toCBOR(){return A.encodeByteString(this.data)}toBitString(){return new Ct(this.data)}}class Yr{_coins;constructor(t){this._coins=t}get coins(){return Array.from(this._coins.entries()).map(([t,e])=>[Vr.fromJSON(t),e])}static create(t){const e=new Map;for(const[r,n]of t)e.set(r.toJSON(),n);return new Yr(e)}static fromCBOR(t){const e=new Map,r=N.readArray(t);for(const t of r){const[r,n]=N.readArray(t);e.set(b.encode(N.readByteString(r)),_t.decode(N.readByteString(n)))}return new Yr(e)}static fromJSON(t){if(!Array.isArray(t)||!t.every(t=>Array.isArray(t)&&2===t.length&&"string"==typeof t[0]&&"string"==typeof t[1]))throw new Error("Invalid coin data JSON format");return new Yr(new Map(t.map(([t,e])=>[t,BigInt(e)])))}toCBOR(){return A.encodeArray(Array.from(this._coins.entries()).map(([t,e])=>A.encodeArray([A.encodeByteString(b.decode(t)),A.encodeByteString(_t.encode(e))])))}toJSON(){return Array.from(this._coins.entries()).map(([t,e])=>[t.toString(),e.toString()])}toString(){return sr`
      TokenCoinData:
        ${Array.from(this._coins.entries()).map(([t,e])=>`${t}: ${e}`).join("\n")}`}}class Zr{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static create(t){return new Zr(t)}toJSON(){return b.encode(this._bytes)}toCBOR(){return A.encodeByteString(this._bytes)}toString(){return`TokenId[${b.encode(this._bytes)}]`}toBitString(){return new Ct(this.toCBOR())}}class Wr{_bytes;constructor(t){this._bytes=t,this._bytes=new Uint8Array(t)}get bytes(){return new Uint8Array(this._bytes)}static create(t){return new Wr(t)}toJSON(){return b.encode(this._bytes)}toCBOR(){return A.encodeByteString(this._bytes)}toString(){return`TokenType[${b.encode(this._bytes)}]`}}const Xr=b.decode("9e82002c144d7c5796c50f6db50a0c7bbd7f717ae3af6c6c71a3e9eba3022730");class Qr{hash;tokenId;tokenType;_tokenData;coinData;sourceState;recipient;_salt;dataHash;reason;constructor(t,e,r,n,i,s,o,a,c,h){this.hash=t,this.tokenId=e,this.tokenType=r,this._tokenData=n,this.coinData=i,this.sourceState=s,this.recipient=o,this._salt=a,this.dataHash=c,this.reason=h,this._tokenData=new Uint8Array(n),this._salt=new Uint8Array(a)}get tokenData(){return new Uint8Array(this._tokenData)}get salt(){return new Uint8Array(this._salt)}get hashAlgorithm(){return this.hash.algorithm}static async create(t,e,r,n,i,s,o,a){const c=await Pt.createFromImprint(t.bytes,Xr),h=await new vt(O.SHA256).update(r).digest();return new Qr(await new vt(O.SHA256).update(A.encodeArray([t.toCBOR(),e.toCBOR(),h.toCBOR(),o?.toCBOR()??A.encodeNull(),n?.toCBOR()??A.encodeNull(),A.encodeTextString(i),A.encodeByteString(s),a?.toCBOR()??A.encodeNull()])).digest(),t,e,r,n,c,i,s,o,a)}toString(){return sr`
      MintTransactionData:
        Token ID: ${this.tokenId.toString()}
        Token Type: ${this.tokenType.toString()}
        Token Data: ${b.encode(this._tokenData)}
        Coins: ${this.coinData?.toString()??null}
        Recipient: ${this.recipient}
        Salt: ${b.encode(this.salt)}
        Data: ${this.dataHash?.toString()??null}
        Reason: ${this.reason?.toString()??null}
        Hash: ${this.hash.toString()}`}}class tn{tokenSerializer;constructor(t){this.tokenSerializer=t}static serialize(t){return A.encodeArray([t.tokenId.toCBOR(),t.tokenType.toCBOR(),A.encodeByteString(t.tokenData),t.coinData?.toCBOR()??A.encodeNull(),A.encodeTextString(t.recipient),A.encodeByteString(t.salt),t.dataHash?.toCBOR()??A.encodeNull(),t.reason?.toCBOR()??A.encodeNull()])}async deserialize(t){const e=N.readArray(t);return Qr.create(Zr.create(N.readByteString(e[0])),Wr.create(N.readByteString(e[1])),N.readByteString(e[2]),N.readOptional(e[3],Yr.fromCBOR),N.readTextString(e[4]),N.readByteString(e[5]),N.readOptional(e[6],R.fromCBOR),await N.readOptional(e[7],this.createMintReason))}createMintReason(t){const e=N.readArray(t),r=N.readTextString(e[0]);if(r===Fr.TOKEN_SPLIT)return this.createSplitMintReason(t);throw new Error(`Unsupported mint reason type: ${r}`)}async createSplitMintReason(t){const e=N.readArray(t),r=new Map,n=await this.tokenSerializer.deserialize(e[0]),i=N.readArray(e[1]);for(const t of i){const e=N.readArray(t),n=_t.decode(N.readByteString(e[0])),i=N.readArray(e[1]);r.set(BigInt(n),new Gr(dr.fromCBOR(i[0]),Lr.fromCBOR(i[1])))}return new jr(n,r)}}class en{data;inclusionProof;constructor(t,e){this.data=t,this.inclusionProof=e}async containsData(t){return this.data.dataHash?!!t&&(await new vt(this.data.dataHash.algorithm).update(t).digest()).equals(this.data.dataHash):!t}toString(){return sr`
        Transaction:
          ${this.data.toString()}
          ${this.inclusionProof.toString()}`}}class rn{dataSerializer;constructor(t){this.dataSerializer=new tn(t)}static serialize(t){return A.encodeArray([tn.serialize(t.data),t.inclusionProof.toCBOR()])}async deserialize(t){const e=N.readArray(t);return new en(await this.dataSerializer.deserialize(e[0]),yr.fromCBOR(e[1]))}}class nn{hash;sourceState;recipient;_salt;dataHash;_message;_nametagTokens;constructor(t,e,r,n,i,s,o=[]){this.hash=t,this.sourceState=e,this.recipient=r,this._salt=n,this.dataHash=i,this._message=s,this._nametagTokens=o,this._message=s?new Uint8Array(s):null,this._nametagTokens=Array.from(o)}get salt(){return new Uint8Array(this._salt)}get message(){return this._message?new Uint8Array(this._message):null}get hashAlgorithm(){return this.hash.algorithm}get nametagTokens(){return this._nametagTokens.slice()}static async create(t,e,r,n,i,s=[]){return new nn(await new vt(O.SHA256).update(A.encodeArray([t.hash.toCBOR(),n?.toCBOR()??A.encodeNull(),A.encodeTextString(e),A.encodeByteString(r),A.encodeOptional(i,A.encodeByteString)])).digest(),t,e,r,n,i,s)}toString(){return sr`
      TransactionData:
        ${this.sourceState.toString()}
        Recipient: ${this.recipient.toString()}
        Salt: ${b.encode(this._salt)}
        Data: ${this.dataHash?.toString()??null}
        Message: ${this._message?b.encode(this._message):null}
        NameTags: [
          ${this._nametagTokens.map(t=>t.toString()).join("\n")}
        ]
        Hash: ${this.hash.toString()}`}}class sn{tokenStateSerializer;constructor(t){this.tokenStateSerializer=new zr(t)}static serialize(t){const e=t.message;return A.encodeArray([zr.serialize(t.sourceState),A.encodeTextString(t.recipient),A.encodeByteString(t.salt),t.dataHash?.toCBOR()??A.encodeNull(),A.encodeOptional(e,A.encodeByteString),A.encodeArray(t.nametagTokens.map(t=>t.toCBOR()))])}async deserialize(t,e,r){const n=N.readArray(r);return nn.create(await this.tokenStateSerializer.deserialize(t,e,n[0]),N.readTextString(n[1]),N.readByteString(n[2]),N.readOptional(n[3],R.fromCBOR),N.readOptional(n[4],N.readByteString),[])}}class on{dataSerializer;constructor(t){this.dataSerializer=new sn(t)}static serialize(t){return A.encodeArray([sn.serialize(t.data),t.inclusionProof.toCBOR()])}async deserialize(t,e,r){const n=N.readArray(r);return new en(await this.dataSerializer.deserialize(t,e,n[0]),yr.fromCBOR(n[1]))}}class an{predicateFactory;mintTransactionSerializer;transactionSerializer;stateSerializer;constructor(t){this.predicateFactory=t,this.mintTransactionSerializer=new rn(this),this.transactionSerializer=new on(t),this.stateSerializer=new zr(t)}static serialize(t){return A.encodeArray([A.encodeTextString(t.version),rn.serialize(t.genesis),A.encodeArray(t.transactions.map(t=>on.serialize(t))),zr.serialize(t.state),A.encodeArray(t.nametagTokens.map(t=>t.toCBOR()))])}async deserialize(t){const e=N.readArray(t),r=N.readTextString(e[0]);if(r!==gn)throw new Error(`Cannot parse token. Version mismatch: ${r} !== ${gn}`);const n=await this.mintTransactionSerializer.deserialize(e[1]),i=[];for(const t of N.readArray(e[2]))i.push(await this.transactionSerializer.deserialize(n.data.tokenId,n.data.tokenType,t));return new yn(await this.stateSerializer.deserialize(n.data.tokenId,n.data.tokenType,e[3]),n,i,[],r)}}class cn{predicateFactory;constructor(t){this.predicateFactory=t}static serialize(t){const e=t.data;return{data:e?b.encode(e):null,unlockPredicate:t.unlockPredicate.toJSON()}}async deserialize(t,e,r){return Dr.create(await this.predicateFactory.create(t,e,r.unlockPredicate),r.data?b.decode(r.data):null)}}class hn{tokenSerializer;constructor(t){this.tokenSerializer=t}static serialize(t){return{coins:t.coinData?.toJSON()??null,dataHash:t.dataHash?.toJSON()??null,reason:t.reason?.toJSON()??null,recipient:t.recipient,salt:b.encode(t.salt),tokenData:b.encode(t.tokenData),tokenId:t.tokenId.toJSON(),tokenType:t.tokenType.toJSON()}}async deserialize(t){return Qr.create(Zr.create(b.decode(t.tokenId)),Wr.create(b.decode(t.tokenType)),b.decode(t.tokenData),t.coins?Yr.fromJSON(t.coins):null,t.recipient,b.decode(t.salt),t.dataHash?R.fromJSON(t.dataHash):null,t.reason?await this.createMintReason(t.reason):null)}createMintReason(t){if(t.type===Fr.TOKEN_SPLIT)return this.createSplitMintReason(t);throw new Error(`Unsupported mint reason type: ${t.type}`)}async createSplitMintReason(t){const e=new Map;for(const[r,n]of t.proofs)e.set(BigInt(r),new Gr(dr.fromJSON(n.aggregationPath),Lr.fromJSON(n.coinTreePath)));return new jr(await this.tokenSerializer.deserialize(t.token),e)}}class un{dataSerializer;constructor(t){this.dataSerializer=new hn(t)}static serialize(t){return{data:hn.serialize(t.data),inclusionProof:t.inclusionProof.toJSON()}}async deserialize({data:t,inclusionProof:e}){return new en(await this.dataSerializer.deserialize(t),yr.fromJSON(e))}}class ln{tokenStateSerializer;constructor(t){this.tokenStateSerializer=new cn(t)}static serialize(t){const e=t.message;return{dataHash:t.dataHash?.toJSON()??null,message:e?b.encode(e):null,nameTags:[],recipient:t.recipient,salt:b.encode(t.salt),sourceState:cn.serialize(t.sourceState)}}async deserialize(t,e,r){return nn.create(await this.tokenStateSerializer.deserialize(t,e,r.sourceState),r.recipient,b.decode(r.salt),r.dataHash?R.fromJSON(r.dataHash):null,r.message?b.decode(r.message):null,[])}}class dn{dataSerializer;constructor(t){this.dataSerializer=new ln(t)}static serialize(t){return{data:ln.serialize(t.data),inclusionProof:t.inclusionProof.toJSON()}}async deserialize(t,e,{data:r,inclusionProof:n}){return new en(await this.dataSerializer.deserialize(t,e,r),yr.fromJSON(n))}}class fn{predicateFactory;mintTransactionDeserializer;transactionSerializer;stateSerializer;constructor(t){this.predicateFactory=t,this.mintTransactionDeserializer=new un(this),this.transactionSerializer=new dn(t),this.stateSerializer=new cn(t)}static serialize(t){return{genesis:un.serialize(t.genesis),nametagTokens:[],state:cn.serialize(t.state),transactions:t.transactions.map(t=>dn.serialize(t)),version:t.version}}async deserialize(t){const e=t.version;if(e!==gn)throw new Error(`Cannot parse token. Version mismatch: ${e} !== ${gn}`);const r=await this.mintTransactionDeserializer.deserialize(t.genesis),n=[];for(const e of t.transactions)n.push(await this.transactionSerializer.deserialize(r.data.tokenId,r.data.tokenType,e));return new yn(await this.stateSerializer.deserialize(r.data.tokenId,r.data.tokenType,t.state),r,n,[],e)}}const gn="2.0";class yn{state;genesis;_transactions;_nametagTokens;version;constructor(t,e,r=[],n=[],i=gn){this.state=t,this.genesis=e,this._transactions=r,this._nametagTokens=n,this.version=i,this._nametagTokens=n.slice(),this._transactions=r.slice()}get id(){return this.genesis.data.tokenId}get type(){return this.genesis.data.tokenType}get data(){return this.genesis.data.tokenData}get coins(){return this.genesis.data.coinData}get nametagTokens(){return this._nametagTokens.slice()}get transactions(){return this._transactions.slice()}toJSON(){return fn.serialize(this)}toCBOR(){return an.serialize(this)}toString(){return sr`
        Token[${this.version}]:
          Id: ${this.id.toString()}
          Type: ${this.type.toString()}
          Data: 
            ${this.data.toString()}
          Coins:
            ${this.coins?.toString()??null}
          State:
            ${this.state.toString()}
          Transactions: [
            ${this.transactions.map(t=>t.toString()).join("\n")}
          ]
          Nametag Tokens: [ 
            ${this.nametagTokens.map(t=>t.toString()).join("\n")}
          ]
      `}}class pn{requestId;transactionData;authenticator;constructor(t,e,r){this.requestId=t,this.transactionData=e,this.authenticator=r}static async create(t,e){const r=await Pt.create(e.publicKey,t.sourceState.hash),n=await or.create(e,t.hash,t.sourceState.hash);return new pn(r,t,n)}}const wn=b.decode("495f414d5f554e4956455253414c5f4d494e5445525f464f525f");class mn{client;constructor(t){this.client=t}async submitMintTransaction(t){const e=await pn.create(t,await ir.createFromSecret(wn,t.tokenId.bytes)),r=await this.client.submitTransaction(e.requestId,e.transactionData.hash,e.authenticator);if(r.status!==gr.SUCCESS)throw new Error(`Could not submit transaction: ${r.status}`);return e}submitCommitment(t){if(!t.transactionData.sourceState.unlockPredicate.isOwner(t.authenticator.publicKey))throw new Error("Ownership verification failed: Authenticator does not match source state predicate.");return this.client.submitTransaction(t.requestId,t.transactionData.hash,t.authenticator)}async createTransaction({requestId:t,transactionData:e},r){if(await r.verify(t)!=fr.OK)throw new Error("Inclusion proof verification failed.");if(!r.authenticator||!O[r.authenticator.stateHash.algorithm])throw new Error("Invalid inclusion proof hash algorithm.");if(!r.transactionHash?.equals(e.hash))throw new Error("Payload hash mismatch");return new en(e,r)}async finishTransaction(t,e,r,n=[]){if(!await r.data.sourceState.unlockPredicate.verify(r))throw new Error("Predicate verification failed");if((await xt.create(e.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");const i=[...t.transactions,r];if(!await r.containsData(e.data))throw new Error("State data is not part of transaction.");return new yn(e,t.genesis,i,n)}async getTokenStatus(t,e){const r=await Pt.create(e,t.state.hash);return(await this.client.getInclusionProof(r)).verify(r)}getInclusionProof(t){return this.client.getInclusionProof(t.requestId)}}class Sn{deserializer;constructor(t){this.deserializer=t}async create(t){const e=await this.deserializer.deserialize(t);if(!await this.verifyMintTransaction(e.genesis))throw new Error("Mint transaction verification failed.");let r=e.genesis;for(const t of e.transactions){if((await xt.create(t.data.sourceState.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");if(!await r.containsData(t.data.sourceState.data))throw new Error("State data is not part of transaction.");if(!await t.data.sourceState.unlockPredicate.verify(t))throw new Error("Predicate verification failed");r=t}if(!await r.containsData(e.state.data))throw new Error("State data is not part of transaction.");if((await xt.create(e.state.unlockPredicate.reference)).toJSON()!==r.data.recipient)throw new Error("Recipient address mismatch");return e}async verifyMintTransaction(t){if(!t.inclusionProof.authenticator||!t.inclusionProof.transactionHash)return!1;const e=await ir.createFromSecret(wn,t.data.tokenId.bytes);if(b.encode(t.inclusionProof.authenticator.publicKey)!==b.encode(e.publicKey)||!t.inclusionProof.authenticator.stateHash.equals(t.data.sourceState.hash))return!1;if(!await t.inclusionProof.authenticator.verify(t.data.hash))return!1;const r=t.data.reason;if(r instanceof jr){if(null==t.data.coinData)return!1;if(r.token.state.unlockPredicate.type!=Ir.BURN)return!1;const e=new Map(t.data.coinData?.coins.map(([t,e])=>[t.toBitString().toBigInt(),e])??[]);if(e?.size!==r.proofs.size)return!1;for(const[n,i]of r.proofs){if(!(await i.aggregationPath.verify(n)).result)return!1;if(!(await i.coinTreePath.verify(t.data.tokenId.toBitString().toBigInt())).result)return!1;const s=i.aggregationPath.steps.at(0)?.branch?.value;if(!s||!i.coinTreePath.root.equals(R.fromImprint(s)))return!1;const o=i.coinTreePath.steps.at(0)?.branch?.sum;if(e.get(n)!==o)return!1;const a=r.token.state.unlockPredicate;if(!i.aggregationPath.root.equals(a.reason))return!1}}const n=await Pt.create(e.publicKey,t.data.sourceState.hash);return await t.inclusionProof.verify(n)===fr.OK}}class bn extends Error{constructor(t){super(t),this.name="SleepError"}}function An(t,e){return new Promise((r,n)=>{const i=setTimeout(r,t);e.addEventListener("abort",()=>{clearTimeout(i),n(e.reason)},{once:!0})})}async function On(t,e,r=AbortSignal.timeout(1e4),n=1e3){for(;;){try{const r=await t.getInclusionProof(e);if(await r.verify(e.requestId)===fr.OK)return r}catch(t){if(!(t instanceof Nr&&404===t.status))throw t}try{await An(n,r)}catch(t){throw new bn(String(t||"Sleep was aborted"))}}}return n})());